"use strict";(self.webpackChunkgallery=self.webpackChunkgallery||[]).push([[334],{4395:(e,t,s)=>{s.d(t,{AO:()=>o,q3:()=>ci,uT:()=>z,xu:()=>R});class i{constructor(e){void 0===e&&(e=[0,0,0,0,0,0,0,0,0]),this.elements=e}identity(){const e=this.elements;e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1}setZero(){const e=this.elements;e[0]=0,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=0,e[6]=0,e[7]=0,e[8]=0}setTrace(e){const t=this.elements;t[0]=e.x,t[4]=e.y,t[8]=e.z}getTrace(e){void 0===e&&(e=new o);const t=this.elements;return e.x=t[0],e.y=t[4],e.z=t[8],e}vmult(e,t){void 0===t&&(t=new o);const s=this.elements,i=e.x,n=e.y,r=e.z;return t.x=s[0]*i+s[1]*n+s[2]*r,t.y=s[3]*i+s[4]*n+s[5]*r,t.z=s[6]*i+s[7]*n+s[8]*r,t}smult(e){for(let t=0;t<this.elements.length;t++)this.elements[t]*=e}mmult(e,t){void 0===t&&(t=new i);const s=this.elements,n=e.elements,o=t.elements,r=s[0],a=s[1],l=s[2],c=s[3],h=s[4],u=s[5],d=s[6],p=s[7],m=s[8],f=n[0],v=n[1],y=n[2],g=n[3],w=n[4],x=n[5],A=n[6],b=n[7],E=n[8];return o[0]=r*f+a*g+l*A,o[1]=r*v+a*w+l*b,o[2]=r*y+a*x+l*E,o[3]=c*f+h*g+u*A,o[4]=c*v+h*w+u*b,o[5]=c*y+h*x+u*E,o[6]=d*f+p*g+m*A,o[7]=d*v+p*w+m*b,o[8]=d*y+p*x+m*E,t}scale(e,t){void 0===t&&(t=new i);const s=this.elements,n=t.elements;for(let t=0;3!==t;t++)n[3*t+0]=e.x*s[3*t+0],n[3*t+1]=e.y*s[3*t+1],n[3*t+2]=e.z*s[3*t+2];return t}solve(e,t){void 0===t&&(t=new o);const s=[];let i,n;for(i=0;i<12;i++)s.push(0);for(i=0;i<3;i++)for(n=0;n<3;n++)s[i+4*n]=this.elements[i+3*n];s[3]=e.x,s[7]=e.y,s[11]=e.z;let r=3;const a=r;let l;let c;do{if(i=a-r,0===s[i+4*i])for(n=i+1;n<a;n++)if(0!==s[i+4*n]){l=4;do{c=4-l,s[c+4*i]+=s[c+4*n]}while(--l);break}if(0!==s[i+4*i])for(n=i+1;n<a;n++){const e=s[i+4*n]/s[i+4*i];l=4;do{c=4-l,s[c+4*n]=c<=i?0:s[c+4*n]-s[c+4*i]*e}while(--l)}}while(--r);if(t.z=s[11]/s[10],t.y=(s[7]-s[6]*t.z)/s[5],t.x=(s[3]-s[2]*t.z-s[1]*t.y)/s[0],isNaN(t.x)||isNaN(t.y)||isNaN(t.z)||t.x===1/0||t.y===1/0||t.z===1/0)throw"Could not solve equation! Got x=[".concat(t.toString(),"], b=[").concat(e.toString(),"], A=[").concat(this.toString(),"]");return t}e(e,t,s){if(void 0===s)return this.elements[t+3*e];this.elements[t+3*e]=s}copy(e){for(let t=0;t<e.elements.length;t++)this.elements[t]=e.elements[t];return this}toString(){let e="";for(let t=0;t<9;t++)e+=this.elements[t]+",";return e}reverse(e){void 0===e&&(e=new i);const t=n;let s,o;for(s=0;s<3;s++)for(o=0;o<3;o++)t[s+6*o]=this.elements[s+3*o];t[3]=1,t[9]=0,t[15]=0,t[4]=0,t[10]=1,t[16]=0,t[5]=0,t[11]=0,t[17]=1;let r=3;const a=r;let l;let c;do{if(s=a-r,0===t[s+6*s])for(o=s+1;o<a;o++)if(0!==t[s+6*o]){l=6;do{c=6-l,t[c+6*s]+=t[c+6*o]}while(--l);break}if(0!==t[s+6*s])for(o=s+1;o<a;o++){const e=t[s+6*o]/t[s+6*s];l=6;do{c=6-l,t[c+6*o]=c<=s?0:t[c+6*o]-t[c+6*s]*e}while(--l)}}while(--r);s=2;do{o=s-1;do{const e=t[s+6*o]/t[s+6*s];l=6;do{c=6-l,t[c+6*o]=t[c+6*o]-t[c+6*s]*e}while(--l)}while(o--)}while(--s);s=2;do{const e=1/t[s+6*s];l=6;do{c=6-l,t[c+6*s]=t[c+6*s]*e}while(--l)}while(s--);s=2;do{o=2;do{if(c=t[3+o+6*s],isNaN(c)||c===1/0)throw"Could not reverse! A=[".concat(this.toString(),"]");e.e(s,o,c)}while(o--)}while(s--);return e}setRotationFromQuaternion(e){const t=e.x,s=e.y,i=e.z,n=e.w,o=t+t,r=s+s,a=i+i,l=t*o,c=t*r,h=t*a,u=s*r,d=s*a,p=i*a,m=n*o,f=n*r,v=n*a,y=this.elements;return y[0]=1-(u+p),y[1]=c-v,y[2]=h+f,y[3]=c+v,y[4]=1-(l+p),y[5]=d-m,y[6]=h-f,y[7]=d+m,y[8]=1-(l+u),this}transpose(e){void 0===e&&(e=new i);const t=this.elements,s=e.elements;let n;return s[0]=t[0],s[4]=t[4],s[8]=t[8],n=t[1],s[1]=t[3],s[3]=n,n=t[2],s[2]=t[6],s[6]=n,n=t[5],s[5]=t[7],s[7]=n,e}}const n=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];class o{constructor(e,t,s){void 0===e&&(e=0),void 0===t&&(t=0),void 0===s&&(s=0),this.x=e,this.y=t,this.z=s}cross(e,t){void 0===t&&(t=new o);const s=e.x,i=e.y,n=e.z,r=this.x,a=this.y,l=this.z;return t.x=a*n-l*i,t.y=l*s-r*n,t.z=r*i-a*s,t}set(e,t,s){return this.x=e,this.y=t,this.z=s,this}setZero(){this.x=this.y=this.z=0}vadd(e,t){if(!t)return new o(this.x+e.x,this.y+e.y,this.z+e.z);t.x=e.x+this.x,t.y=e.y+this.y,t.z=e.z+this.z}vsub(e,t){if(!t)return new o(this.x-e.x,this.y-e.y,this.z-e.z);t.x=this.x-e.x,t.y=this.y-e.y,t.z=this.z-e.z}crossmat(){return new i([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])}normalize(){const e=this.x,t=this.y,s=this.z,i=Math.sqrt(e*e+t*t+s*s);if(i>0){const e=1/i;this.x*=e,this.y*=e,this.z*=e}else this.x=0,this.y=0,this.z=0;return i}unit(e){void 0===e&&(e=new o);const t=this.x,s=this.y,i=this.z;let n=Math.sqrt(t*t+s*s+i*i);return n>0?(n=1/n,e.x=t*n,e.y=s*n,e.z=i*n):(e.x=1,e.y=0,e.z=0),e}length(){const e=this.x,t=this.y,s=this.z;return Math.sqrt(e*e+t*t+s*s)}lengthSquared(){return this.dot(this)}distanceTo(e){const t=this.x,s=this.y,i=this.z,n=e.x,o=e.y,r=e.z;return Math.sqrt((n-t)*(n-t)+(o-s)*(o-s)+(r-i)*(r-i))}distanceSquared(e){const t=this.x,s=this.y,i=this.z,n=e.x,o=e.y,r=e.z;return(n-t)*(n-t)+(o-s)*(o-s)+(r-i)*(r-i)}scale(e,t){void 0===t&&(t=new o);const s=this.x,i=this.y,n=this.z;return t.x=e*s,t.y=e*i,t.z=e*n,t}vmul(e,t){return void 0===t&&(t=new o),t.x=e.x*this.x,t.y=e.y*this.y,t.z=e.z*this.z,t}addScaledVector(e,t,s){return void 0===s&&(s=new o),s.x=this.x+e*t.x,s.y=this.y+e*t.y,s.z=this.z+e*t.z,s}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}isZero(){return 0===this.x&&0===this.y&&0===this.z}negate(e){return void 0===e&&(e=new o),e.x=-this.x,e.y=-this.y,e.z=-this.z,e}tangents(e,t){const s=this.length();if(s>0){const i=r,n=1/s;i.set(this.x*n,this.y*n,this.z*n);const o=a;Math.abs(i.x)<.9?(o.set(1,0,0),i.cross(o,e)):(o.set(0,1,0),i.cross(o,e)),i.cross(e,t)}else e.set(1,0,0),t.set(0,1,0)}toString(){return"".concat(this.x,",").concat(this.y,",").concat(this.z)}toArray(){return[this.x,this.y,this.z]}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}lerp(e,t,s){const i=this.x,n=this.y,o=this.z;s.x=i+(e.x-i)*t,s.y=n+(e.y-n)*t,s.z=o+(e.z-o)*t}almostEquals(e,t){return void 0===t&&(t=1e-6),!(Math.abs(this.x-e.x)>t||Math.abs(this.y-e.y)>t||Math.abs(this.z-e.z)>t)}almostZero(e){return void 0===e&&(e=1e-6),!(Math.abs(this.x)>e||Math.abs(this.y)>e||Math.abs(this.z)>e)}isAntiparallelTo(e,t){return this.negate(l),l.almostEquals(e,t)}clone(){return new o(this.x,this.y,this.z)}}o.ZERO=new o(0,0,0),o.UNIT_X=new o(1,0,0),o.UNIT_Y=new o(0,1,0),o.UNIT_Z=new o(0,0,1);const r=new o,a=new o,l=new o;class c{constructor(e){void 0===e&&(e={}),this.lowerBound=new o,this.upperBound=new o,e.lowerBound&&this.lowerBound.copy(e.lowerBound),e.upperBound&&this.upperBound.copy(e.upperBound)}setFromPoints(e,t,s,i){const n=this.lowerBound,o=this.upperBound,r=s;n.copy(e[0]),r&&r.vmult(n,n),o.copy(n);for(let t=1;t<e.length;t++){let s=e[t];r&&(r.vmult(s,h),s=h),s.x>o.x&&(o.x=s.x),s.x<n.x&&(n.x=s.x),s.y>o.y&&(o.y=s.y),s.y<n.y&&(n.y=s.y),s.z>o.z&&(o.z=s.z),s.z<n.z&&(n.z=s.z)}return t&&(t.vadd(n,n),t.vadd(o,o)),i&&(n.x-=i,n.y-=i,n.z-=i,o.x+=i,o.y+=i,o.z+=i),this}copy(e){return this.lowerBound.copy(e.lowerBound),this.upperBound.copy(e.upperBound),this}clone(){return(new c).copy(this)}extend(e){this.lowerBound.x=Math.min(this.lowerBound.x,e.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,e.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,e.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,e.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,e.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,e.upperBound.z)}overlaps(e){const t=this.lowerBound,s=this.upperBound,i=e.lowerBound,n=e.upperBound,o=i.x<=s.x&&s.x<=n.x||t.x<=n.x&&n.x<=s.x,r=i.y<=s.y&&s.y<=n.y||t.y<=n.y&&n.y<=s.y,a=i.z<=s.z&&s.z<=n.z||t.z<=n.z&&n.z<=s.z;return o&&r&&a}volume(){const e=this.lowerBound,t=this.upperBound;return(t.x-e.x)*(t.y-e.y)*(t.z-e.z)}contains(e){const t=this.lowerBound,s=this.upperBound,i=e.lowerBound,n=e.upperBound;return t.x<=i.x&&s.x>=n.x&&t.y<=i.y&&s.y>=n.y&&t.z<=i.z&&s.z>=n.z}getCorners(e,t,s,i,n,o,r,a){const l=this.lowerBound,c=this.upperBound;e.copy(l),t.set(c.x,l.y,l.z),s.set(c.x,c.y,l.z),i.set(l.x,c.y,c.z),n.set(c.x,l.y,c.z),o.set(l.x,c.y,l.z),r.set(l.x,l.y,c.z),a.copy(c)}toLocalFrame(e,t){const s=u,i=s[0],n=s[1],o=s[2],r=s[3],a=s[4],l=s[5],c=s[6],h=s[7];this.getCorners(i,n,o,r,a,l,c,h);for(let t=0;8!==t;t++){const i=s[t];e.pointToLocal(i,i)}return t.setFromPoints(s)}toWorldFrame(e,t){const s=u,i=s[0],n=s[1],o=s[2],r=s[3],a=s[4],l=s[5],c=s[6],h=s[7];this.getCorners(i,n,o,r,a,l,c,h);for(let t=0;8!==t;t++){const i=s[t];e.pointToWorld(i,i)}return t.setFromPoints(s)}overlapsRay(e){const{direction:t,from:s}=e,i=1/t.x,n=1/t.y,o=1/t.z,r=(this.lowerBound.x-s.x)*i,a=(this.upperBound.x-s.x)*i,l=(this.lowerBound.y-s.y)*n,c=(this.upperBound.y-s.y)*n,h=(this.lowerBound.z-s.z)*o,u=(this.upperBound.z-s.z)*o,d=Math.max(Math.max(Math.min(r,a),Math.min(l,c)),Math.min(h,u)),p=Math.min(Math.min(Math.max(r,a),Math.max(l,c)),Math.max(h,u));return!(p<0)&&!(d>p)}}const h=new o,u=[new o,new o,new o,new o,new o,new o,new o,new o];class d{constructor(){this.matrix=[]}get(e,t){let{index:s}=e,{index:i}=t;if(i>s){const e=i;i=s,s=e}return this.matrix[(s*(s+1)>>1)+i-1]}set(e,t,s){let{index:i}=e,{index:n}=t;if(n>i){const e=n;n=i,i=e}this.matrix[(i*(i+1)>>1)+n-1]=s?1:0}reset(){for(let e=0,t=this.matrix.length;e!==t;e++)this.matrix[e]=0}setNumObjects(e){this.matrix.length=e*(e-1)>>1}}class p{addEventListener(e,t){void 0===this._listeners&&(this._listeners={});const s=this._listeners;return void 0===s[e]&&(s[e]=[]),s[e].includes(t)||s[e].push(t),this}hasEventListener(e,t){if(void 0===this._listeners)return!1;const s=this._listeners;return!(void 0===s[e]||!s[e].includes(t))}hasAnyEventListener(e){if(void 0===this._listeners)return!1;return void 0!==this._listeners[e]}removeEventListener(e,t){if(void 0===this._listeners)return this;const s=this._listeners;if(void 0===s[e])return this;const i=s[e].indexOf(t);return-1!==i&&s[e].splice(i,1),this}dispatchEvent(e){if(void 0===this._listeners)return this;const t=this._listeners[e.type];if(void 0!==t){e.target=this;for(let s=0,i=t.length;s<i;s++)t[s].call(this,e)}return this}}class m{constructor(e,t,s,i){void 0===e&&(e=0),void 0===t&&(t=0),void 0===s&&(s=0),void 0===i&&(i=1),this.x=e,this.y=t,this.z=s,this.w=i}set(e,t,s,i){return this.x=e,this.y=t,this.z=s,this.w=i,this}toString(){return"".concat(this.x,",").concat(this.y,",").concat(this.z,",").concat(this.w)}toArray(){return[this.x,this.y,this.z,this.w]}setFromAxisAngle(e,t){const s=Math.sin(.5*t);return this.x=e.x*s,this.y=e.y*s,this.z=e.z*s,this.w=Math.cos(.5*t),this}toAxisAngle(e){void 0===e&&(e=new o),this.normalize();const t=2*Math.acos(this.w),s=Math.sqrt(1-this.w*this.w);return s<.001?(e.x=this.x,e.y=this.y,e.z=this.z):(e.x=this.x/s,e.y=this.y/s,e.z=this.z/s),[e,t]}setFromVectors(e,t){if(e.isAntiparallelTo(t)){const t=f,s=v;e.tangents(t,s),this.setFromAxisAngle(t,Math.PI)}else{const s=e.cross(t);this.x=s.x,this.y=s.y,this.z=s.z,this.w=Math.sqrt(e.length()**2*t.length()**2)+e.dot(t),this.normalize()}return this}mult(e,t){void 0===t&&(t=new m);const s=this.x,i=this.y,n=this.z,o=this.w,r=e.x,a=e.y,l=e.z,c=e.w;return t.x=s*c+o*r+i*l-n*a,t.y=i*c+o*a+n*r-s*l,t.z=n*c+o*l+s*a-i*r,t.w=o*c-s*r-i*a-n*l,t}inverse(e){void 0===e&&(e=new m);const t=this.x,s=this.y,i=this.z,n=this.w;this.conjugate(e);const o=1/(t*t+s*s+i*i+n*n);return e.x*=o,e.y*=o,e.z*=o,e.w*=o,e}conjugate(e){return void 0===e&&(e=new m),e.x=-this.x,e.y=-this.y,e.z=-this.z,e.w=this.w,e}normalize(){let e=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return 0===e?(this.x=0,this.y=0,this.z=0,this.w=0):(e=1/e,this.x*=e,this.y*=e,this.z*=e,this.w*=e),this}normalizeFast(){const e=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;return 0===e?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=e,this.y*=e,this.z*=e,this.w*=e),this}vmult(e,t){void 0===t&&(t=new o);const s=e.x,i=e.y,n=e.z,r=this.x,a=this.y,l=this.z,c=this.w,h=c*s+a*n-l*i,u=c*i+l*s-r*n,d=c*n+r*i-a*s,p=-r*s-a*i-l*n;return t.x=h*c+p*-r+u*-l-d*-a,t.y=u*c+p*-a+d*-r-h*-l,t.z=d*c+p*-l+h*-a-u*-r,t}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w,this}toEuler(e,t){let s,i,n;void 0===t&&(t="YZX");const o=this.x,r=this.y,a=this.z,l=this.w;if("YZX"!==t)throw new Error("Euler order ".concat(t," not supported yet."));{const e=o*r+a*l;if(e>.499&&(s=2*Math.atan2(o,l),i=Math.PI/2,n=0),e<-.499&&(s=-2*Math.atan2(o,l),i=-Math.PI/2,n=0),void 0===s){const t=o*o,c=r*r,h=a*a;s=Math.atan2(2*r*l-2*o*a,1-2*c-2*h),i=Math.asin(2*e),n=Math.atan2(2*o*l-2*r*a,1-2*t-2*h)}}e.y=s,e.z=i,e.x=n}setFromEuler(e,t,s,i){void 0===i&&(i="XYZ");const n=Math.cos(e/2),o=Math.cos(t/2),r=Math.cos(s/2),a=Math.sin(e/2),l=Math.sin(t/2),c=Math.sin(s/2);return"XYZ"===i?(this.x=a*o*r+n*l*c,this.y=n*l*r-a*o*c,this.z=n*o*c+a*l*r,this.w=n*o*r-a*l*c):"YXZ"===i?(this.x=a*o*r+n*l*c,this.y=n*l*r-a*o*c,this.z=n*o*c-a*l*r,this.w=n*o*r+a*l*c):"ZXY"===i?(this.x=a*o*r-n*l*c,this.y=n*l*r+a*o*c,this.z=n*o*c+a*l*r,this.w=n*o*r-a*l*c):"ZYX"===i?(this.x=a*o*r-n*l*c,this.y=n*l*r+a*o*c,this.z=n*o*c-a*l*r,this.w=n*o*r+a*l*c):"YZX"===i?(this.x=a*o*r+n*l*c,this.y=n*l*r+a*o*c,this.z=n*o*c-a*l*r,this.w=n*o*r-a*l*c):"XZY"===i&&(this.x=a*o*r-n*l*c,this.y=n*l*r-a*o*c,this.z=n*o*c+a*l*r,this.w=n*o*r+a*l*c),this}clone(){return new m(this.x,this.y,this.z,this.w)}slerp(e,t,s){void 0===s&&(s=new m);const i=this.x,n=this.y,o=this.z,r=this.w;let a,l,c,h,u,d=e.x,p=e.y,f=e.z,v=e.w;return l=i*d+n*p+o*f+r*v,l<0&&(l=-l,d=-d,p=-p,f=-f,v=-v),1-l>1e-6?(a=Math.acos(l),c=Math.sin(a),h=Math.sin((1-t)*a)/c,u=Math.sin(t*a)/c):(h=1-t,u=t),s.x=h*i+u*d,s.y=h*n+u*p,s.z=h*o+u*f,s.w=h*r+u*v,s}integrate(e,t,s,i){void 0===i&&(i=new m);const n=e.x*s.x,o=e.y*s.y,r=e.z*s.z,a=this.x,l=this.y,c=this.z,h=this.w,u=.5*t;return i.x+=u*(n*h+o*c-r*l),i.y+=u*(o*h+r*a-n*c),i.z+=u*(r*h+n*l-o*a),i.w+=u*(-n*a-o*l-r*c),i}}const f=new o,v=new o;class y{constructor(e){void 0===e&&(e={}),this.id=y.idCounter++,this.type=e.type||0,this.boundingSphereRadius=0,this.collisionResponse=!e.collisionResponse||e.collisionResponse,this.collisionFilterGroup=void 0!==e.collisionFilterGroup?e.collisionFilterGroup:1,this.collisionFilterMask=void 0!==e.collisionFilterMask?e.collisionFilterMask:-1,this.material=e.material?e.material:null,this.body=null}updateBoundingSphereRadius(){throw"computeBoundingSphereRadius() not implemented for shape type ".concat(this.type)}volume(){throw"volume() not implemented for shape type ".concat(this.type)}calculateLocalInertia(e,t){throw"calculateLocalInertia() not implemented for shape type ".concat(this.type)}calculateWorldAABB(e,t,s,i){throw"calculateWorldAABB() not implemented for shape type ".concat(this.type)}}y.idCounter=0,y.types={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256};class g{constructor(e){void 0===e&&(e={}),this.position=new o,this.quaternion=new m,e.position&&this.position.copy(e.position),e.quaternion&&this.quaternion.copy(e.quaternion)}pointToLocal(e,t){return g.pointToLocalFrame(this.position,this.quaternion,e,t)}pointToWorld(e,t){return g.pointToWorldFrame(this.position,this.quaternion,e,t)}vectorToWorldFrame(e,t){return void 0===t&&(t=new o),this.quaternion.vmult(e,t),t}static pointToLocalFrame(e,t,s,i){return void 0===i&&(i=new o),s.vsub(e,i),t.conjugate(w),w.vmult(i,i),i}static pointToWorldFrame(e,t,s,i){return void 0===i&&(i=new o),t.vmult(s,i),i.vadd(e,i),i}static vectorToWorldFrame(e,t,s){return void 0===s&&(s=new o),e.vmult(t,s),s}static vectorToLocalFrame(e,t,s,i){return void 0===i&&(i=new o),t.w*=-1,t.vmult(s,i),t.w*=-1,i}}const w=new m;class x extends y{constructor(e){void 0===e&&(e={});const{vertices:t=[],faces:s=[],normals:i=[],axes:n,boundingSphereRadius:o}=e;super({type:y.types.CONVEXPOLYHEDRON}),this.vertices=t,this.faces=s,this.faceNormals=i,0===this.faceNormals.length&&this.computeNormals(),o?this.boundingSphereRadius=o:this.updateBoundingSphereRadius(),this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.worldFaceNormals=[],this.worldFaceNormalsNeedsUpdate=!0,this.uniqueAxes=n?n.slice():null,this.uniqueEdges=[],this.computeEdges()}computeEdges(){const e=this.faces,t=this.vertices,s=this.uniqueEdges;s.length=0;const i=new o;for(let n=0;n!==e.length;n++){const o=e[n],r=o.length;for(let e=0;e!==r;e++){const n=(e+1)%r;t[o[e]].vsub(t[o[n]],i),i.normalize();let a=!1;for(let e=0;e!==s.length;e++)if(s[e].almostEquals(i)||s[e].almostEquals(i)){a=!0;break}a||s.push(i.clone())}}}computeNormals(){this.faceNormals.length=this.faces.length;for(let e=0;e<this.faces.length;e++){for(let t=0;t<this.faces[e].length;t++)if(!this.vertices[this.faces[e][t]])throw new Error("Vertex ".concat(this.faces[e][t]," not found!"));const t=this.faceNormals[e]||new o;this.getFaceNormal(e,t),t.negate(t),this.faceNormals[e]=t;const s=this.vertices[this.faces[e][0]];if(t.dot(s)<0)for(let t=0;t<this.faces[e].length;t++);}}getFaceNormal(e,t){const s=this.faces[e],i=this.vertices[s[0]],n=this.vertices[s[1]],o=this.vertices[s[2]];x.computeNormal(i,n,o,t)}static computeNormal(e,t,s,i){const n=new o,r=new o;t.vsub(e,r),s.vsub(t,n),n.cross(r,i),i.isZero()||i.normalize()}clipAgainstHull(e,t,s,i,n,r,a,l,c){const h=new o;let u=-1,d=-Number.MAX_VALUE;for(let e=0;e<s.faces.length;e++){h.copy(s.faceNormals[e]),n.vmult(h,h);const t=h.dot(r);t>d&&(d=t,u=e)}const p=[];for(let e=0;e<s.faces[u].length;e++){const t=s.vertices[s.faces[u][e]],r=new o;r.copy(t),n.vmult(r,r),i.vadd(r,r),p.push(r)}u>=0&&this.clipFaceAgainstHull(r,e,t,p,a,l,c)}findSeparatingAxis(e,t,s,i,n,r,a,l){const c=new o,h=new o,u=new o,d=new o,p=new o,m=new o;let f=Number.MAX_VALUE;const v=this;if(v.uniqueAxes)for(let o=0;o!==v.uniqueAxes.length;o++){s.vmult(v.uniqueAxes[o],c);const a=v.testSepAxis(c,e,t,s,i,n);if(!1===a)return!1;a<f&&(f=a,r.copy(c))}else{const o=a?a.length:v.faces.length;for(let l=0;l<o;l++){const o=a?a[l]:l;c.copy(v.faceNormals[o]),s.vmult(c,c);const h=v.testSepAxis(c,e,t,s,i,n);if(!1===h)return!1;h<f&&(f=h,r.copy(c))}}if(e.uniqueAxes)for(let o=0;o!==e.uniqueAxes.length;o++){n.vmult(e.uniqueAxes[o],h);const a=v.testSepAxis(h,e,t,s,i,n);if(!1===a)return!1;a<f&&(f=a,r.copy(h))}else{const o=l?l.length:e.faces.length;for(let a=0;a<o;a++){const o=l?l[a]:a;h.copy(e.faceNormals[o]),n.vmult(h,h);const c=v.testSepAxis(h,e,t,s,i,n);if(!1===c)return!1;c<f&&(f=c,r.copy(h))}}for(let o=0;o!==v.uniqueEdges.length;o++){s.vmult(v.uniqueEdges[o],d);for(let o=0;o!==e.uniqueEdges.length;o++)if(n.vmult(e.uniqueEdges[o],p),d.cross(p,m),!m.almostZero()){m.normalize();const o=v.testSepAxis(m,e,t,s,i,n);if(!1===o)return!1;o<f&&(f=o,r.copy(m))}}return i.vsub(t,u),u.dot(r)>0&&r.negate(r),!0}testSepAxis(e,t,s,i,n,o){x.project(this,e,s,i,A),x.project(t,e,n,o,b);const r=A[0],a=A[1],l=b[0],c=b[1];if(r<c||l<a)return!1;const h=r-c,u=l-a;return h<u?h:u}calculateLocalInertia(e,t){const s=new o,i=new o;this.computeLocalAABB(i,s);const n=s.x-i.x,r=s.y-i.y,a=s.z-i.z;t.x=1/12*e*(2*r*2*r+2*a*2*a),t.y=1/12*e*(2*n*2*n+2*a*2*a),t.z=1/12*e*(2*r*2*r+2*n*2*n)}getPlaneConstantOfFace(e){const t=this.faces[e],s=this.faceNormals[e],i=this.vertices[t[0]];return-s.dot(i)}clipFaceAgainstHull(e,t,s,i,n,r,a){const l=new o,c=new o,h=new o,u=new o,d=new o,p=new o,m=new o,f=new o,v=this,y=i,g=[];let w=-1,x=Number.MAX_VALUE;for(let t=0;t<v.faces.length;t++){l.copy(v.faceNormals[t]),s.vmult(l,l);const i=l.dot(e);i<x&&(x=i,w=t)}if(w<0)return;const A=v.faces[w];A.connectedFaces=[];for(let e=0;e<v.faces.length;e++)for(let t=0;t<v.faces[e].length;t++)-1!==A.indexOf(v.faces[e][t])&&e!==w&&-1===A.connectedFaces.indexOf(e)&&A.connectedFaces.push(e);const b=A.length;for(let e=0;e<b;e++){const i=v.vertices[A[e]],n=v.vertices[A[(e+1)%b]];i.vsub(n,c),h.copy(c),s.vmult(h,h),t.vadd(h,h),u.copy(this.faceNormals[w]),s.vmult(u,u),t.vadd(u,u),h.cross(u,d),d.negate(d),p.copy(i),s.vmult(p,p),t.vadd(p,p);const o=A.connectedFaces[e];m.copy(this.faceNormals[o]);const r=this.getPlaneConstantOfFace(o);f.copy(m),s.vmult(f,f);const a=r-f.dot(t);for(this.clipFaceAgainstPlane(y,g,f,a);y.length;)y.shift();for(;g.length;)y.push(g.shift())}m.copy(this.faceNormals[w]);const E=this.getPlaneConstantOfFace(w);f.copy(m),s.vmult(f,f);const T=E-f.dot(t);for(let e=0;e<y.length;e++){let t=f.dot(y[e])+T;if(t<=n&&(t=n),t<=r){const s=y[e];if(t<=1e-6){const e={point:s,normal:f,depth:t};a.push(e)}}}}clipFaceAgainstPlane(e,t,s,i){let n,r;const a=e.length;if(a<2)return t;let l=e[e.length-1],c=e[0];n=s.dot(l)+i;for(let h=0;h<a;h++){if(c=e[h],r=s.dot(c)+i,n<0)if(r<0){const e=new o;e.copy(c),t.push(e)}else{const e=new o;l.lerp(c,n/(n-r),e),t.push(e)}else if(r<0){const e=new o;l.lerp(c,n/(n-r),e),t.push(e),t.push(c)}l=c,n=r}return t}computeWorldVertices(e,t){for(;this.worldVertices.length<this.vertices.length;)this.worldVertices.push(new o);const s=this.vertices,i=this.worldVertices;for(let n=0;n!==this.vertices.length;n++)t.vmult(s[n],i[n]),e.vadd(i[n],i[n]);this.worldVerticesNeedsUpdate=!1}computeLocalAABB(e,t){const s=this.vertices;e.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),t.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let i=0;i<this.vertices.length;i++){const n=s[i];n.x<e.x?e.x=n.x:n.x>t.x&&(t.x=n.x),n.y<e.y?e.y=n.y:n.y>t.y&&(t.y=n.y),n.z<e.z?e.z=n.z:n.z>t.z&&(t.z=n.z)}}computeWorldFaceNormals(e){const t=this.faceNormals.length;for(;this.worldFaceNormals.length<t;)this.worldFaceNormals.push(new o);const s=this.faceNormals,i=this.worldFaceNormals;for(let n=0;n!==t;n++)e.vmult(s[n],i[n]);this.worldFaceNormalsNeedsUpdate=!1}updateBoundingSphereRadius(){let e=0;const t=this.vertices;for(let s=0;s!==t.length;s++){const i=t[s].lengthSquared();i>e&&(e=i)}this.boundingSphereRadius=Math.sqrt(e)}calculateWorldAABB(e,t,s,i){const n=this.vertices;let r,a,l,c,h,u,d=new o;for(let s=0;s<n.length;s++){d.copy(n[s]),t.vmult(d,d),e.vadd(d,d);const i=d;(void 0===r||i.x<r)&&(r=i.x),(void 0===c||i.x>c)&&(c=i.x),(void 0===a||i.y<a)&&(a=i.y),(void 0===h||i.y>h)&&(h=i.y),(void 0===l||i.z<l)&&(l=i.z),(void 0===u||i.z>u)&&(u=i.z)}s.set(r,a,l),i.set(c,h,u)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}getAveragePointLocal(e){void 0===e&&(e=new o);const t=this.vertices;for(let s=0;s<t.length;s++)e.vadd(t[s],e);return e.scale(1/t.length,e),e}transformAllPoints(e,t){const s=this.vertices.length,i=this.vertices;if(t){for(let e=0;e<s;e++){const s=i[e];t.vmult(s,s)}for(let e=0;e<this.faceNormals.length;e++){const s=this.faceNormals[e];t.vmult(s,s)}}if(e)for(let t=0;t<s;t++){const s=i[t];s.vadd(e,s)}}pointIsInside(e){const t=this.vertices,s=this.faces,i=this.faceNormals,n=new o;this.getAveragePointLocal(n);for(let r=0;r<this.faces.length;r++){let a=i[r];const l=t[s[r][0]],c=new o;e.vsub(l,c);const h=a.dot(c),u=new o;n.vsub(l,u);const d=a.dot(u);if(h<0&&d>0||h>0&&d<0)return!1}return-1}static project(e,t,s,i,n){const o=e.vertices.length,r=E;let a=0,l=0;const c=T,h=e.vertices;c.setZero(),g.vectorToLocalFrame(s,i,t,r),g.pointToLocalFrame(s,i,c,c);const u=c.dot(r);l=a=h[0].dot(r);for(let e=1;e<o;e++){const t=h[e].dot(r);t>a&&(a=t),t<l&&(l=t)}if(l-=u,a-=u,l>a){const e=l;l=a,a=e}n[0]=a,n[1]=l}}const A=[],b=[],E=(new o,new o),T=new o;class R extends y{constructor(e){super({type:y.types.BOX}),this.halfExtents=e,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}updateConvexPolyhedronRepresentation(){const e=this.halfExtents.x,t=this.halfExtents.y,s=this.halfExtents.z,i=o,n=[new i(-e,-t,-s),new i(e,-t,-s),new i(e,t,-s),new i(-e,t,-s),new i(-e,-t,s),new i(e,-t,s),new i(e,t,s),new i(-e,t,s)],r=[new i(0,0,1),new i(0,1,0),new i(1,0,0)],a=new x({vertices:n,faces:[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]],axes:r});this.convexPolyhedronRepresentation=a,a.material=this.material}calculateLocalInertia(e,t){return void 0===t&&(t=new o),R.calculateInertia(this.halfExtents,e,t),t}static calculateInertia(e,t,s){const i=e;s.x=1/12*t*(2*i.y*2*i.y+2*i.z*2*i.z),s.y=1/12*t*(2*i.x*2*i.x+2*i.z*2*i.z),s.z=1/12*t*(2*i.y*2*i.y+2*i.x*2*i.x)}getSideNormals(e,t){const s=e,i=this.halfExtents;if(s[0].set(i.x,0,0),s[1].set(0,i.y,0),s[2].set(0,0,i.z),s[3].set(-i.x,0,0),s[4].set(0,-i.y,0),s[5].set(0,0,-i.z),void 0!==t)for(let e=0;e!==s.length;e++)t.vmult(s[e],s[e]);return s}volume(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z}updateBoundingSphereRadius(){this.boundingSphereRadius=this.halfExtents.length()}forEachWorldCorner(e,t,s){const i=this.halfExtents,n=[[i.x,i.y,i.z],[-i.x,i.y,i.z],[-i.x,-i.y,i.z],[-i.x,-i.y,-i.z],[i.x,-i.y,-i.z],[i.x,i.y,-i.z],[-i.x,i.y,-i.z],[i.x,-i.y,i.z]];for(let i=0;i<n.length;i++)S.set(n[i][0],n[i][1],n[i][2]),t.vmult(S,S),e.vadd(S,S),s(S.x,S.y,S.z)}calculateWorldAABB(e,t,s,i){const n=this.halfExtents;M[0].set(n.x,n.y,n.z),M[1].set(-n.x,n.y,n.z),M[2].set(-n.x,-n.y,n.z),M[3].set(-n.x,-n.y,-n.z),M[4].set(n.x,-n.y,-n.z),M[5].set(n.x,n.y,-n.z),M[6].set(-n.x,n.y,-n.z),M[7].set(n.x,-n.y,n.z);const o=M[0];t.vmult(o,o),e.vadd(o,o),i.copy(o),s.copy(o);for(let n=1;n<8;n++){const o=M[n];t.vmult(o,o),e.vadd(o,o);const r=o.x,a=o.y,l=o.z;r>i.x&&(i.x=r),a>i.y&&(i.y=a),l>i.z&&(i.z=l),r<s.x&&(s.x=r),a<s.y&&(s.y=a),l<s.z&&(s.z=l)}}}const S=new o,M=[new o,new o,new o,new o,new o,new o,new o,new o],C=1,I=2,N=4,L=0,F=1,P=2;class z extends p{constructor(e){void 0===e&&(e={}),super(),this.id=z.idCounter++,this.index=-1,this.world=null,this.vlambda=new o,this.collisionFilterGroup="number"==typeof e.collisionFilterGroup?e.collisionFilterGroup:1,this.collisionFilterMask="number"==typeof e.collisionFilterMask?e.collisionFilterMask:-1,this.collisionResponse="boolean"!=typeof e.collisionResponse||e.collisionResponse,this.position=new o,this.previousPosition=new o,this.interpolatedPosition=new o,this.initPosition=new o,e.position&&(this.position.copy(e.position),this.previousPosition.copy(e.position),this.interpolatedPosition.copy(e.position),this.initPosition.copy(e.position)),this.velocity=new o,e.velocity&&this.velocity.copy(e.velocity),this.initVelocity=new o,this.force=new o;const t="number"==typeof e.mass?e.mass:0;this.mass=t,this.invMass=t>0?1/t:0,this.material=e.material||null,this.linearDamping="number"==typeof e.linearDamping?e.linearDamping:.01,this.type=t<=0?z.STATIC:z.DYNAMIC,typeof e.type==typeof z.STATIC&&(this.type=e.type),this.allowSleep=void 0===e.allowSleep||e.allowSleep,this.sleepState=z.AWAKE,this.sleepSpeedLimit=void 0!==e.sleepSpeedLimit?e.sleepSpeedLimit:.1,this.sleepTimeLimit=void 0!==e.sleepTimeLimit?e.sleepTimeLimit:1,this.timeLastSleepy=0,this.wakeUpAfterNarrowphase=!1,this.torque=new o,this.quaternion=new m,this.initQuaternion=new m,this.previousQuaternion=new m,this.interpolatedQuaternion=new m,e.quaternion&&(this.quaternion.copy(e.quaternion),this.initQuaternion.copy(e.quaternion),this.previousQuaternion.copy(e.quaternion),this.interpolatedQuaternion.copy(e.quaternion)),this.angularVelocity=new o,e.angularVelocity&&this.angularVelocity.copy(e.angularVelocity),this.initAngularVelocity=new o,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new o,this.invInertia=new o,this.invInertiaWorld=new i,this.invMassSolve=0,this.invInertiaSolve=new o,this.invInertiaWorldSolve=new i,this.fixedRotation=void 0!==e.fixedRotation&&e.fixedRotation,this.angularDamping=void 0!==e.angularDamping?e.angularDamping:.01,this.linearFactor=new o(1,1,1),e.linearFactor&&this.linearFactor.copy(e.linearFactor),this.angularFactor=new o(1,1,1),e.angularFactor&&this.angularFactor.copy(e.angularFactor),this.aabb=new c,this.aabbNeedsUpdate=!0,this.boundingRadius=0,this.wlambda=new o,this.isTrigger=Boolean(e.isTrigger),e.shape&&this.addShape(e.shape),this.updateMassProperties()}wakeUp(){const e=this.sleepState;this.sleepState=z.AWAKE,this.wakeUpAfterNarrowphase=!1,e===z.SLEEPING&&this.dispatchEvent(z.wakeupEvent)}sleep(){this.sleepState=z.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0),this.wakeUpAfterNarrowphase=!1}sleepTick(e){if(this.allowSleep){const t=this.sleepState,s=this.velocity.lengthSquared()+this.angularVelocity.lengthSquared(),i=this.sleepSpeedLimit**2;t===z.AWAKE&&s<i?(this.sleepState=z.SLEEPY,this.timeLastSleepy=e,this.dispatchEvent(z.sleepyEvent)):t===z.SLEEPY&&s>i?this.wakeUp():t===z.SLEEPY&&e-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(z.sleepEvent))}}updateSolveMassProperties(){this.sleepState===z.SLEEPING||this.type===z.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))}pointToLocalFrame(e,t){return void 0===t&&(t=new o),e.vsub(this.position,t),this.quaternion.conjugate().vmult(t,t),t}vectorToLocalFrame(e,t){return void 0===t&&(t=new o),this.quaternion.conjugate().vmult(e,t),t}pointToWorldFrame(e,t){return void 0===t&&(t=new o),this.quaternion.vmult(e,t),t.vadd(this.position,t),t}vectorToWorldFrame(e,t){return void 0===t&&(t=new o),this.quaternion.vmult(e,t),t}addShape(e,t,s){const i=new o,n=new m;return t&&i.copy(t),s&&n.copy(s),this.shapes.push(e),this.shapeOffsets.push(i),this.shapeOrientations.push(n),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,e.body=this,this}removeShape(e){const t=this.shapes.indexOf(e);return-1===t||(this.shapes.splice(t,1),this.shapeOffsets.splice(t,1),this.shapeOrientations.splice(t,1),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,e.body=null),this}updateBoundingRadius(){const e=this.shapes,t=this.shapeOffsets,s=e.length;let i=0;for(let n=0;n!==s;n++){const s=e[n];s.updateBoundingSphereRadius();const o=t[n].length(),r=s.boundingSphereRadius;o+r>i&&(i=o+r)}this.boundingRadius=i}updateAABB(){const e=this.shapes,t=this.shapeOffsets,s=this.shapeOrientations,i=e.length,n=B,o=_,r=this.quaternion,a=this.aabb,l=O;for(let c=0;c!==i;c++){const i=e[c];r.vmult(t[c],n),n.vadd(this.position,n),r.mult(s[c],o),i.calculateWorldAABB(n,o,l.lowerBound,l.upperBound),0===c?a.copy(l):a.extend(l)}this.aabbNeedsUpdate=!1}updateInertiaWorld(e){const t=this.invInertia;if(t.x!==t.y||t.y!==t.z||e){const e=k,s=j;e.setRotationFromQuaternion(this.quaternion),e.transpose(s),e.scale(t,e),e.mmult(s,this.invInertiaWorld)}else;}applyForce(e,t){if(void 0===t&&(t=new o),this.type!==z.DYNAMIC)return;this.sleepState===z.SLEEPING&&this.wakeUp();const s=q;t.cross(e,s),this.force.vadd(e,this.force),this.torque.vadd(s,this.torque)}applyLocalForce(e,t){if(void 0===t&&(t=new o),this.type!==z.DYNAMIC)return;const s=H,i=D;this.vectorToWorldFrame(e,s),this.vectorToWorldFrame(t,i),this.applyForce(s,i)}applyTorque(e){this.type===z.DYNAMIC&&(this.sleepState===z.SLEEPING&&this.wakeUp(),this.torque.vadd(e,this.torque))}applyImpulse(e,t){if(void 0===t&&(t=new o),this.type!==z.DYNAMIC)return;this.sleepState===z.SLEEPING&&this.wakeUp();const s=t,i=U;i.copy(e),i.scale(this.invMass,i),this.velocity.vadd(i,this.velocity);const n=G;s.cross(e,n),this.invInertiaWorld.vmult(n,n),this.angularVelocity.vadd(n,this.angularVelocity)}applyLocalImpulse(e,t){if(void 0===t&&(t=new o),this.type!==z.DYNAMIC)return;const s=V,i=W;this.vectorToWorldFrame(e,s),this.vectorToWorldFrame(t,i),this.applyImpulse(s,i)}updateMassProperties(){const e=K;this.invMass=this.mass>0?1/this.mass:0;const t=this.inertia,s=this.fixedRotation;this.updateAABB(),e.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),R.calculateInertia(e,this.mass,t),this.invInertia.set(t.x>0&&!s?1/t.x:0,t.y>0&&!s?1/t.y:0,t.z>0&&!s?1/t.z:0),this.updateInertiaWorld(!0)}getVelocityAtWorldPoint(e,t){const s=new o;return e.vsub(this.position,s),this.angularVelocity.cross(s,t),this.velocity.vadd(t,t),t}integrate(e,t,s){if(this.previousPosition.copy(this.position),this.previousQuaternion.copy(this.quaternion),this.type!==z.DYNAMIC&&this.type!==z.KINEMATIC||this.sleepState===z.SLEEPING)return;const i=this.velocity,n=this.angularVelocity,o=this.position,r=this.force,a=this.torque,l=this.quaternion,c=this.invMass,h=this.invInertiaWorld,u=this.linearFactor,d=c*e;i.x+=r.x*d*u.x,i.y+=r.y*d*u.y,i.z+=r.z*d*u.z;const p=h.elements,m=this.angularFactor,f=a.x*m.x,v=a.y*m.y,y=a.z*m.z;n.x+=e*(p[0]*f+p[1]*v+p[2]*y),n.y+=e*(p[3]*f+p[4]*v+p[5]*y),n.z+=e*(p[6]*f+p[7]*v+p[8]*y),o.x+=i.x*e,o.y+=i.y*e,o.z+=i.z*e,l.integrate(this.angularVelocity,e,this.angularFactor,l),t&&(s?l.normalizeFast():l.normalize()),this.aabbNeedsUpdate=!0,this.updateInertiaWorld()}}z.idCounter=0,z.COLLIDE_EVENT_NAME="collide",z.DYNAMIC=C,z.STATIC=I,z.KINEMATIC=N,z.AWAKE=L,z.SLEEPY=F,z.SLEEPING=P,z.wakeupEvent={type:"wakeup"},z.sleepyEvent={type:"sleepy"},z.sleepEvent={type:"sleep"};const B=new o,_=new m,O=new c,k=new i,j=new i,q=(new i,new o),H=new o,D=new o,U=new o,G=new o,V=new o,W=new o,K=new o;class X{constructor(){this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}collisionPairs(e,t,s){throw new Error("collisionPairs not implemented for this BroadPhase class!")}needBroadphaseCollision(e,t){return 0!=(e.collisionFilterGroup&t.collisionFilterMask)&&0!=(t.collisionFilterGroup&e.collisionFilterMask)&&(0==(e.type&z.STATIC)&&e.sleepState!==z.SLEEPING||0==(t.type&z.STATIC)&&t.sleepState!==z.SLEEPING)}intersectionTest(e,t,s,i){this.useBoundingBoxes?this.doBoundingBoxBroadphase(e,t,s,i):this.doBoundingSphereBroadphase(e,t,s,i)}doBoundingSphereBroadphase(e,t,s,i){const n=Y;t.position.vsub(e.position,n);const o=(e.boundingRadius+t.boundingRadius)**2;n.lengthSquared()<o&&(s.push(e),i.push(t))}doBoundingBoxBroadphase(e,t,s,i){e.aabbNeedsUpdate&&e.updateAABB(),t.aabbNeedsUpdate&&t.updateAABB(),e.aabb.overlaps(t.aabb)&&(s.push(e),i.push(t))}makePairsUnique(e,t){const s=Z,i=Q,n=J,o=e.length;for(let s=0;s!==o;s++)i[s]=e[s],n[s]=t[s];e.length=0,t.length=0;for(let e=0;e!==o;e++){const t=i[e].id,o=n[e].id,r=t<o?"".concat(t,",").concat(o):"".concat(o,",").concat(t);s[r]=e,s.keys.push(r)}for(let o=0;o!==s.keys.length;o++){const o=s.keys.pop(),r=s[o];e.push(i[r]),t.push(n[r]),delete s[o]}}setWorld(e){}static boundingSphereCheck(e,t){const s=new o;e.position.vsub(t.position,s);const i=e.shapes[0],n=t.shapes[0];return Math.pow(i.boundingSphereRadius+n.boundingSphereRadius,2)>s.lengthSquared()}aabbQuery(e,t,s){return[]}}const Y=new o;new o,new m,new o;const Z={keys:[]},Q=[],J=[];new o;new o;new o;class $ extends X{constructor(){super()}collisionPairs(e,t,s){const i=e.bodies,n=i.length;let o,r;for(let e=0;e!==n;e++)for(let n=0;n!==e;n++)o=i[e],r=i[n],this.needBroadphaseCollision(o,r)&&this.intersectionTest(o,r,t,s)}aabbQuery(e,t,s){void 0===s&&(s=[]);for(let i=0;i<e.bodies.length;i++){const n=e.bodies[i];n.aabbNeedsUpdate&&n.updateAABB(),n.aabb.overlaps(t)&&s.push(n)}return s}}class ee{constructor(){this.rayFromWorld=new o,this.rayToWorld=new o,this.hitNormalWorld=new o,this.hitPointWorld=new o,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}reset(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}abort(){this.shouldStop=!0}set(e,t,s,i,n,o,r){this.rayFromWorld.copy(e),this.rayToWorld.copy(t),this.hitNormalWorld.copy(s),this.hitPointWorld.copy(i),this.shape=n,this.body=o,this.distance=r}}let te,se,ie,ne,oe,re,ae;const le=1,ce=2,he=4;te=y.types.SPHERE,se=y.types.PLANE,ie=y.types.BOX,ne=y.types.CYLINDER,oe=y.types.CONVEXPOLYHEDRON,re=y.types.HEIGHTFIELD,ae=y.types.TRIMESH;class ue{get[te](){return this._intersectSphere}get[se](){return this._intersectPlane}get[ie](){return this._intersectBox}get[ne](){return this._intersectConvex}get[oe](){return this._intersectConvex}get[re](){return this._intersectHeightfield}get[ae](){return this._intersectTrimesh}constructor(e,t){void 0===e&&(e=new o),void 0===t&&(t=new o),this.from=e.clone(),this.to=t.clone(),this.direction=new o,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=ue.ANY,this.result=new ee,this.hasHit=!1,this.callback=e=>{}}intersectWorld(e,t){return this.mode=t.mode||ue.ANY,this.result=t.result||new ee,this.skipBackfaces=!!t.skipBackfaces,this.collisionFilterMask=void 0!==t.collisionFilterMask?t.collisionFilterMask:-1,this.collisionFilterGroup=void 0!==t.collisionFilterGroup?t.collisionFilterGroup:-1,this.checkCollisionResponse=void 0===t.checkCollisionResponse||t.checkCollisionResponse,t.from&&this.from.copy(t.from),t.to&&this.to.copy(t.to),this.callback=t.callback||(()=>{}),this.hasHit=!1,this.result.reset(),this.updateDirection(),this.getAABB(de),pe.length=0,e.broadphase.aabbQuery(e,de,pe),this.intersectBodies(pe),this.hasHit}intersectBody(e,t){t&&(this.result=t,this.updateDirection());const s=this.checkCollisionResponse;if(s&&!e.collisionResponse)return;if(0==(this.collisionFilterGroup&e.collisionFilterMask)||0==(e.collisionFilterGroup&this.collisionFilterMask))return;const i=ve,n=ye;for(let t=0,o=e.shapes.length;t<o;t++){const o=e.shapes[t];if((!s||o.collisionResponse)&&(e.quaternion.mult(e.shapeOrientations[t],n),e.quaternion.vmult(e.shapeOffsets[t],i),i.vadd(e.position,i),this.intersectShape(o,n,i,e),this.result.shouldStop))break}}intersectBodies(e,t){t&&(this.result=t,this.updateDirection());for(let t=0,s=e.length;!this.result.shouldStop&&t<s;t++)this.intersectBody(e[t])}updateDirection(){this.to.vsub(this.from,this.direction),this.direction.normalize()}intersectShape(e,t,s,i){const n=function(e,t,s){s.vsub(e,ke);const i=ke.dot(t);t.scale(i,je),je.vadd(e,je);const n=s.distanceTo(je);return n}(this.from,this.direction,s);if(n>e.boundingSphereRadius)return;const o=this[e.type];o&&o.call(this,e,t,s,i,e)}_intersectBox(e,t,s,i,n){return this._intersectConvex(e.convexPolyhedronRepresentation,t,s,i,n)}_intersectPlane(e,t,s,i,n){const r=this.from,a=this.to,l=this.direction,c=new o(0,0,1);t.vmult(c,c);const h=new o;r.vsub(s,h);const u=h.dot(c);a.vsub(s,h);if(u*h.dot(c)>0)return;if(r.distanceTo(a)<u)return;const d=c.dot(l);if(Math.abs(d)<this.precision)return;const p=new o,m=new o,f=new o;r.vsub(s,p);const v=-c.dot(p)/d;l.scale(v,m),r.vadd(m,f),this.reportIntersection(c,f,n,i,-1)}getAABB(e){const{lowerBound:t,upperBound:s}=e,i=this.to,n=this.from;t.x=Math.min(i.x,n.x),t.y=Math.min(i.y,n.y),t.z=Math.min(i.z,n.z),s.x=Math.max(i.x,n.x),s.y=Math.max(i.y,n.y),s.z=Math.max(i.z,n.z)}_intersectHeightfield(e,t,s,i,n){e.data,e.elementSize;const o=Te;o.from.copy(this.from),o.to.copy(this.to),g.pointToLocalFrame(s,t,o.from,o.from),g.pointToLocalFrame(s,t,o.to,o.to),o.updateDirection();const r=Re;let a,l,h,u;a=l=0,h=u=e.data.length-1;const d=new c;o.getAABB(d),e.getIndexOfPosition(d.lowerBound.x,d.lowerBound.y,r,!0),a=Math.max(a,r[0]),l=Math.max(l,r[1]),e.getIndexOfPosition(d.upperBound.x,d.upperBound.y,r,!0),h=Math.min(h,r[0]+1),u=Math.min(u,r[1]+1);for(let r=a;r<h;r++)for(let a=l;a<u;a++){if(this.result.shouldStop)return;if(e.getAabbAtIndex(r,a,d),d.overlapsRay(o)){if(e.getConvexTrianglePillar(r,a,!1),g.pointToWorldFrame(s,t,e.pillarOffset,Ee),this._intersectConvex(e.pillarConvex,t,Ee,i,n,be),this.result.shouldStop)return;e.getConvexTrianglePillar(r,a,!0),g.pointToWorldFrame(s,t,e.pillarOffset,Ee),this._intersectConvex(e.pillarConvex,t,Ee,i,n,be)}}}_intersectSphere(e,t,s,i,n){const o=this.from,r=this.to,a=e.radius,l=(r.x-o.x)**2+(r.y-o.y)**2+(r.z-o.z)**2,c=2*((r.x-o.x)*(o.x-s.x)+(r.y-o.y)*(o.y-s.y)+(r.z-o.z)*(o.z-s.z)),h=c**2-4*l*((o.x-s.x)**2+(o.y-s.y)**2+(o.z-s.z)**2-a**2),u=Se,d=Me;if(!(h<0))if(0===h)o.lerp(r,h,u),u.vsub(s,d),d.normalize(),this.reportIntersection(d,u,n,i,-1);else{const e=(-c-Math.sqrt(h))/(2*l),t=(-c+Math.sqrt(h))/(2*l);if(e>=0&&e<=1&&(o.lerp(r,e,u),u.vsub(s,d),d.normalize(),this.reportIntersection(d,u,n,i,-1)),this.result.shouldStop)return;t>=0&&t<=1&&(o.lerp(r,t,u),u.vsub(s,d),d.normalize(),this.reportIntersection(d,u,n,i,-1))}}_intersectConvex(e,t,s,i,n,o){const r=Ce,a=Ie,l=o&&o.faceList||null,c=e.faces,h=e.vertices,u=e.faceNormals,d=this.direction,p=this.from,m=this.to,f=p.distanceTo(m),v=l?l.length:c.length,y=this.result;for(let e=0;!y.shouldStop&&e<v;e++){const o=l?l[e]:e,m=c[o],v=u[o],g=t,w=s;a.copy(h[m[0]]),g.vmult(a,a),a.vadd(w,a),a.vsub(p,a),g.vmult(v,r);const x=d.dot(r);if(Math.abs(x)<this.precision)continue;const A=r.dot(a)/x;if(!(A<0)){d.scale(A,ge),ge.vadd(p,ge),we.copy(h[m[0]]),g.vmult(we,we),w.vadd(we,we);for(let e=1;!y.shouldStop&&e<m.length-1;e++){xe.copy(h[m[e]]),Ae.copy(h[m[e+1]]),g.vmult(xe,xe),g.vmult(Ae,Ae),w.vadd(xe,xe),w.vadd(Ae,Ae);const t=ge.distanceTo(p);!ue.pointInTriangle(ge,we,xe,Ae)&&!ue.pointInTriangle(ge,xe,we,Ae)||t>f||this.reportIntersection(r,ge,n,i,o)}}}}_intersectTrimesh(e,t,s,i,n,o){const r=Ne,a=_e,l=Oe,c=Ie,h=Le,u=Fe,d=Pe,p=Be,m=ze,f=e.indices;e.vertices;const v=this.from,y=this.to,w=this.direction;l.position.copy(s),l.quaternion.copy(t),g.vectorToLocalFrame(s,t,w,h),g.pointToLocalFrame(s,t,v,u),g.pointToLocalFrame(s,t,y,d),d.x*=e.scale.x,d.y*=e.scale.y,d.z*=e.scale.z,u.x*=e.scale.x,u.y*=e.scale.y,u.z*=e.scale.z,d.vsub(u,h),h.normalize();const x=u.distanceSquared(d);e.tree.rayQuery(this,l,a);for(let o=0,l=a.length;!this.result.shouldStop&&o!==l;o++){const l=a[o];e.getNormal(l,r),e.getVertex(f[3*l],we),we.vsub(u,c);const d=h.dot(r),v=r.dot(c)/d;if(v<0)continue;h.scale(v,ge),ge.vadd(u,ge),e.getVertex(f[3*l+1],xe),e.getVertex(f[3*l+2],Ae);const y=ge.distanceSquared(u);!ue.pointInTriangle(ge,xe,we,Ae)&&!ue.pointInTriangle(ge,we,xe,Ae)||y>x||(g.vectorToWorldFrame(t,r,m),g.pointToWorldFrame(s,t,ge,p),this.reportIntersection(m,p,n,i,l))}a.length=0}reportIntersection(e,t,s,i,n){const o=this.from,r=this.to,a=o.distanceTo(t),l=this.result;if(!(this.skipBackfaces&&e.dot(this.direction)>0))switch(l.hitFaceIndex=void 0!==n?n:-1,this.mode){case ue.ALL:this.hasHit=!0,l.set(o,r,e,t,s,i,a),l.hasHit=!0,this.callback(l);break;case ue.CLOSEST:(a<l.distance||!l.hasHit)&&(this.hasHit=!0,l.hasHit=!0,l.set(o,r,e,t,s,i,a));break;case ue.ANY:this.hasHit=!0,l.hasHit=!0,l.set(o,r,e,t,s,i,a),l.shouldStop=!0}}static pointInTriangle(e,t,s,i){i.vsub(t,ke),s.vsub(t,me),e.vsub(t,fe);const n=ke.dot(ke),o=ke.dot(me),r=ke.dot(fe),a=me.dot(me),l=me.dot(fe);let c,h;return(c=a*r-o*l)>=0&&(h=n*l-o*r)>=0&&c+h<n*a-o*o}}ue.CLOSEST=le,ue.ANY=ce,ue.ALL=he;const de=new c,pe=[],me=new o,fe=new o,ve=new o,ye=new m,ge=new o,we=new o,xe=new o,Ae=new o;new o,new ee;const be={faceList:[0]},Ee=new o,Te=new ue,Re=[],Se=new o,Me=new o,Ce=new o,Ie=(new o,new o,new o),Ne=new o,Le=new o,Fe=new o,Pe=new o,ze=new o,Be=new o;new c;const _e=[],Oe=new g,ke=new o,je=new o;class qe{static defaults(e,t){void 0===e&&(e={});for(let s in t)s in e||(e[s]=t[s]);return e}}class He{constructor(e,t,s){void 0===s&&(s={}),s=qe.defaults(s,{collideConnected:!0,wakeUpBodies:!0}),this.equations=[],this.bodyA=e,this.bodyB=t,this.id=He.idCounter++,this.collideConnected=s.collideConnected,s.wakeUpBodies&&(e&&e.wakeUp(),t&&t.wakeUp())}update(){throw new Error("method update() not implmemented in this Constraint subclass!")}enable(){const e=this.equations;for(let t=0;t<e.length;t++)e[t].enabled=!0}disable(){const e=this.equations;for(let t=0;t<e.length;t++)e[t].enabled=!1}}He.idCounter=0;class De{constructor(){this.spatial=new o,this.rotational=new o}multiplyElement(e){return e.spatial.dot(this.spatial)+e.rotational.dot(this.rotational)}multiplyVectors(e,t){return e.dot(this.spatial)+t.dot(this.rotational)}}class Ue{constructor(e,t,s,i){void 0===s&&(s=-1e6),void 0===i&&(i=1e6),this.id=Ue.idCounter++,this.minForce=s,this.maxForce=i,this.bi=e,this.bj=t,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new De,this.jacobianElementB=new De,this.enabled=!0,this.multiplier=0,this.setSpookParams(1e7,4,1/60)}setSpookParams(e,t,s){const i=t,n=e,o=s;this.a=4/(o*(1+4*i)),this.b=4*i/(1+4*i),this.eps=4/(o*o*n*(1+4*i))}computeB(e,t,s){const i=this.computeGW();return-this.computeGq()*e-i*t-this.computeGiMf()*s}computeGq(){const e=this.jacobianElementA,t=this.jacobianElementB,s=this.bi,i=this.bj,n=s.position,o=i.position;return e.spatial.dot(n)+t.spatial.dot(o)}computeGW(){const e=this.jacobianElementA,t=this.jacobianElementB,s=this.bi,i=this.bj,n=s.velocity,o=i.velocity,r=s.angularVelocity,a=i.angularVelocity;return e.multiplyVectors(n,r)+t.multiplyVectors(o,a)}computeGWlambda(){const e=this.jacobianElementA,t=this.jacobianElementB,s=this.bi,i=this.bj,n=s.vlambda,o=i.vlambda,r=s.wlambda,a=i.wlambda;return e.multiplyVectors(n,r)+t.multiplyVectors(o,a)}computeGiMf(){const e=this.jacobianElementA,t=this.jacobianElementB,s=this.bi,i=this.bj,n=s.force,o=s.torque,r=i.force,a=i.torque,l=s.invMassSolve,c=i.invMassSolve;return n.scale(l,Ge),r.scale(c,Ve),s.invInertiaWorldSolve.vmult(o,We),i.invInertiaWorldSolve.vmult(a,Ke),e.multiplyVectors(Ge,We)+t.multiplyVectors(Ve,Ke)}computeGiMGt(){const e=this.jacobianElementA,t=this.jacobianElementB,s=this.bi,i=this.bj,n=s.invMassSolve,o=i.invMassSolve,r=s.invInertiaWorldSolve,a=i.invInertiaWorldSolve;let l=n+o;return r.vmult(e.rotational,Xe),l+=Xe.dot(e.rotational),a.vmult(t.rotational,Xe),l+=Xe.dot(t.rotational),l}addToWlambda(e){const t=this.jacobianElementA,s=this.jacobianElementB,i=this.bi,n=this.bj,o=Ye;i.vlambda.addScaledVector(i.invMassSolve*e,t.spatial,i.vlambda),n.vlambda.addScaledVector(n.invMassSolve*e,s.spatial,n.vlambda),i.invInertiaWorldSolve.vmult(t.rotational,o),i.wlambda.addScaledVector(e,o,i.wlambda),n.invInertiaWorldSolve.vmult(s.rotational,o),n.wlambda.addScaledVector(e,o,n.wlambda)}computeC(){return this.computeGiMGt()+this.eps}}Ue.idCounter=0;const Ge=new o,Ve=new o,We=new o,Ke=new o,Xe=new o,Ye=new o;class Ze extends Ue{constructor(e,t,s){void 0===s&&(s=1e6),super(e,t,0,s),this.restitution=0,this.ri=new o,this.rj=new o,this.ni=new o}computeB(e){const t=this.a,s=this.b,i=this.bi,n=this.bj,o=this.ri,r=this.rj,a=Qe,l=Je,c=i.velocity,h=i.angularVelocity;i.force,i.torque;const u=n.velocity,d=n.angularVelocity;n.force,n.torque;const p=$e,m=this.jacobianElementA,f=this.jacobianElementB,v=this.ni;o.cross(v,a),r.cross(v,l),v.negate(m.spatial),a.negate(m.rotational),f.spatial.copy(v),f.rotational.copy(l),p.copy(n.position),p.vadd(r,p),p.vsub(i.position,p),p.vsub(o,p);const y=v.dot(p),g=this.restitution+1;return-y*t-(g*u.dot(v)-g*c.dot(v)+d.dot(l)-h.dot(a))*s-e*this.computeGiMf()}getImpactVelocityAlongNormal(){const e=et,t=tt,s=st,i=it,n=nt;return this.bi.position.vadd(this.ri,s),this.bj.position.vadd(this.rj,i),this.bi.getVelocityAtWorldPoint(s,e),this.bj.getVelocityAtWorldPoint(i,t),e.vsub(t,n),this.ni.dot(n)}}const Qe=new o,Je=new o,$e=new o,et=new o,tt=new o,st=new o,it=new o,nt=new o;new o,new o;new o,new o;new o,new o;new o,new o;new o,new o;class ot extends Ue{constructor(e,t,s){super(e,t,-s,s),this.ri=new o,this.rj=new o,this.t=new o}computeB(e){this.a;const t=this.b;this.bi,this.bj;const s=this.ri,i=this.rj,n=rt,o=at,r=this.t;s.cross(r,n),i.cross(r,o);const a=this.jacobianElementA,l=this.jacobianElementB;r.negate(a.spatial),n.negate(a.rotational),l.spatial.copy(r),l.rotational.copy(o);return-this.computeGW()*t-e*this.computeGiMf()}}const rt=new o,at=new o;class lt{constructor(e,t,s){s=qe.defaults(s,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=lt.idCounter++,this.materials=[e,t],this.friction=s.friction,this.restitution=s.restitution,this.contactEquationStiffness=s.contactEquationStiffness,this.contactEquationRelaxation=s.contactEquationRelaxation,this.frictionEquationStiffness=s.frictionEquationStiffness,this.frictionEquationRelaxation=s.frictionEquationRelaxation}}lt.idCounter=0;class ct{constructor(e){void 0===e&&(e={});let t="";"string"==typeof e&&(t=e,e={}),this.name=t,this.id=ct.idCounter++,this.friction=void 0!==e.friction?e.friction:-1,this.restitution=void 0!==e.restitution?e.restitution:-1}}ct.idCounter=0;new o,new o,new o,new o,new o,new o,new o,new o,new o,new o,new o;new o,new o;new o,new o,new o;new o,new o,new o;new ue,new o;new o,new o,new o(1,0,0),new o(0,1,0),new o(0,0,1),new o,new o,new o,new o;new o,new o,new o,new o;new o,new o,new o;new o,new o;new o,new o,new o,new o,new o,new o,new o;new o;new o,new o,new o,new o,new o,new o,new o,new o,new o;new o,new c;new o,new c,new o,new o,new o,new o,new o,new o,new o,new c,new o,new g,new c;class ht{constructor(){this.equations=[]}solve(e,t){return 0}addEquation(e){!e.enabled||e.bi.isTrigger||e.bj.isTrigger||this.equations.push(e)}removeEquation(e){const t=this.equations,s=t.indexOf(e);-1!==s&&t.splice(s,1)}removeAllEquations(){this.equations.length=0}}class ut extends ht{constructor(){super(),this.iterations=10,this.tolerance=1e-7}solve(e,t){let s=0;const i=this.iterations,n=this.tolerance*this.tolerance,o=this.equations,r=o.length,a=t.bodies,l=a.length,c=e;let h,u,d,p,m,f;if(0!==r)for(let e=0;e!==l;e++)a[e].updateSolveMassProperties();const v=pt,y=mt,g=dt;v.length=r,y.length=r,g.length=r;for(let e=0;e!==r;e++){const t=o[e];g[e]=0,y[e]=t.computeB(c),v[e]=1/t.computeC()}if(0!==r){for(let e=0;e!==l;e++){const t=a[e],s=t.vlambda,i=t.wlambda;s.set(0,0,0),i.set(0,0,0)}for(s=0;s!==i;s++){p=0;for(let e=0;e!==r;e++){const t=o[e];h=y[e],u=v[e],f=g[e],m=t.computeGWlambda(),d=u*(h-m-t.eps*f),f+d<t.minForce?d=t.minForce-f:f+d>t.maxForce&&(d=t.maxForce-f),g[e]+=d,p+=d>0?d:-d,t.addToWlambda(d)}if(p*p<n)break}for(let e=0;e!==l;e++){const t=a[e],s=t.velocity,i=t.angularVelocity;t.vlambda.vmul(t.linearFactor,t.vlambda),s.vadd(t.vlambda,s),t.wlambda.vmul(t.angularFactor,t.wlambda),i.vadd(t.wlambda,i)}let e=o.length;const t=1/c;for(;e--;)o[e].multiplier=g[e]*t}return s}}const dt=[],pt=[],mt=[];z.STATIC;class ft{constructor(){this.objects=[],this.type=Object}release(){const e=arguments.length;for(let t=0;t!==e;t++)this.objects.push(t<0||arguments.length<=t?void 0:arguments[t]);return this}get(){return 0===this.objects.length?this.constructObject():this.objects.pop()}constructObject(){throw new Error("constructObject() not implemented in this Pool subclass yet!")}resize(e){const t=this.objects;for(;t.length>e;)t.pop();for(;t.length<e;)t.push(this.constructObject());return this}}class vt extends ft{constructor(){super(...arguments),this.type=o}constructObject(){return new o}}const yt=y.types.SPHERE,gt=y.types.SPHERE|y.types.PLANE,wt=y.types.BOX|y.types.BOX,xt=y.types.SPHERE|y.types.BOX,At=y.types.PLANE|y.types.BOX,bt=y.types.CONVEXPOLYHEDRON,Et=y.types.SPHERE|y.types.CONVEXPOLYHEDRON,Tt=y.types.PLANE|y.types.CONVEXPOLYHEDRON,Rt=y.types.BOX|y.types.CONVEXPOLYHEDRON,St=y.types.SPHERE|y.types.HEIGHTFIELD,Mt=y.types.BOX|y.types.HEIGHTFIELD,Ct=y.types.CONVEXPOLYHEDRON|y.types.HEIGHTFIELD,It=y.types.PARTICLE|y.types.SPHERE,Nt=y.types.PLANE|y.types.PARTICLE,Lt=y.types.BOX|y.types.PARTICLE,Ft=y.types.PARTICLE|y.types.CONVEXPOLYHEDRON,Pt=y.types.CYLINDER,zt=y.types.SPHERE|y.types.CYLINDER,Bt=y.types.PLANE|y.types.CYLINDER,_t=y.types.BOX|y.types.CYLINDER,Ot=y.types.CONVEXPOLYHEDRON|y.types.CYLINDER,kt=y.types.HEIGHTFIELD|y.types.CYLINDER,jt=y.types.PARTICLE|y.types.CYLINDER,qt=y.types.SPHERE|y.types.TRIMESH,Ht=y.types.PLANE|y.types.TRIMESH;class Dt{get[yt](){return this.sphereSphere}get[gt](){return this.spherePlane}get[wt](){return this.boxBox}get[xt](){return this.sphereBox}get[At](){return this.planeBox}get[bt](){return this.convexConvex}get[Et](){return this.sphereConvex}get[Tt](){return this.planeConvex}get[Rt](){return this.boxConvex}get[St](){return this.sphereHeightfield}get[Mt](){return this.boxHeightfield}get[Ct](){return this.convexHeightfield}get[It](){return this.sphereParticle}get[Nt](){return this.planeParticle}get[Lt](){return this.boxParticle}get[Ft](){return this.convexParticle}get[Pt](){return this.convexConvex}get[zt](){return this.sphereConvex}get[Bt](){return this.planeConvex}get[_t](){return this.boxConvex}get[Ot](){return this.convexConvex}get[kt](){return this.heightfieldCylinder}get[jt](){return this.particleCylinder}get[qt](){return this.sphereTrimesh}get[Ht](){return this.planeTrimesh}constructor(e){this.contactPointPool=[],this.frictionEquationPool=[],this.result=[],this.frictionResult=[],this.v3pool=new vt,this.world=e,this.currentContactMaterial=e.defaultContactMaterial,this.enableFrictionReduction=!1}createContactEquation(e,t,s,i,n,o){let r;this.contactPointPool.length?(r=this.contactPointPool.pop(),r.bi=e,r.bj=t):r=new Ze(e,t),r.enabled=e.collisionResponse&&t.collisionResponse&&s.collisionResponse&&i.collisionResponse;const a=this.currentContactMaterial;r.restitution=a.restitution,r.setSpookParams(a.contactEquationStiffness,a.contactEquationRelaxation,this.world.dt);const l=s.material||e.material,c=i.material||t.material;return l&&c&&l.restitution>=0&&c.restitution>=0&&(r.restitution=l.restitution*c.restitution),r.si=n||s,r.sj=o||i,r}createFrictionEquationsFromContact(e,t){const s=e.bi,i=e.bj,n=e.si,o=e.sj,r=this.world,a=this.currentContactMaterial;let l=a.friction;const c=n.material||s.material,h=o.material||i.material;if(c&&h&&c.friction>=0&&h.friction>=0&&(l=c.friction*h.friction),l>0){const n=l*(r.frictionGravity||r.gravity).length();let o=s.invMass+i.invMass;o>0&&(o=1/o);const c=this.frictionEquationPool,h=c.length?c.pop():new ot(s,i,n*o),u=c.length?c.pop():new ot(s,i,n*o);return h.bi=u.bi=s,h.bj=u.bj=i,h.minForce=u.minForce=-n*o,h.maxForce=u.maxForce=n*o,h.ri.copy(e.ri),h.rj.copy(e.rj),u.ri.copy(e.ri),u.rj.copy(e.rj),e.ni.tangents(h.t,u.t),h.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,r.dt),u.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,r.dt),h.enabled=u.enabled=e.enabled,t.push(h,u),!0}return!1}createFrictionFromAverage(e){let t=this.result[this.result.length-1];if(!this.createFrictionEquationsFromContact(t,this.frictionResult)||1===e)return;const s=this.frictionResult[this.frictionResult.length-2],i=this.frictionResult[this.frictionResult.length-1];Ut.setZero(),Gt.setZero(),Vt.setZero();const n=t.bi;t.bj;for(let s=0;s!==e;s++)t=this.result[this.result.length-1-s],t.bi!==n?(Ut.vadd(t.ni,Ut),Gt.vadd(t.ri,Gt),Vt.vadd(t.rj,Vt)):(Ut.vsub(t.ni,Ut),Gt.vadd(t.rj,Gt),Vt.vadd(t.ri,Vt));const o=1/e;Gt.scale(o,s.ri),Vt.scale(o,s.rj),i.ri.copy(s.ri),i.rj.copy(s.rj),Ut.normalize(),Ut.tangents(s.t,i.t)}getContacts(e,t,s,i,n,o,r){this.contactPointPool=n,this.frictionEquationPool=r,this.result=i,this.frictionResult=o;const a=Xt,l=Yt,c=Wt,h=Kt;for(let i=0,n=e.length;i!==n;i++){const n=e[i],o=t[i];let r=null;n.material&&o.material&&(r=s.getContactMaterial(n.material,o.material)||null);const u=n.type&z.KINEMATIC&&o.type&z.STATIC||n.type&z.STATIC&&o.type&z.KINEMATIC||n.type&z.KINEMATIC&&o.type&z.KINEMATIC;for(let e=0;e<n.shapes.length;e++){n.quaternion.mult(n.shapeOrientations[e],a),n.quaternion.vmult(n.shapeOffsets[e],c),c.vadd(n.position,c);const t=n.shapes[e];for(let e=0;e<o.shapes.length;e++){o.quaternion.mult(o.shapeOrientations[e],l),o.quaternion.vmult(o.shapeOffsets[e],h),h.vadd(o.position,h);const i=o.shapes[e];if(!(t.collisionFilterMask&i.collisionFilterGroup&&i.collisionFilterMask&t.collisionFilterGroup))continue;if(c.distanceTo(h)>t.boundingSphereRadius+i.boundingSphereRadius)continue;let d=null;t.material&&i.material&&(d=s.getContactMaterial(t.material,i.material)||null),this.currentContactMaterial=d||r||s.defaultContactMaterial;const p=this[t.type|i.type];if(p){let e=!1;e=t.type<i.type?p.call(this,t,i,c,h,a,l,n,o,t,i,u):p.call(this,i,t,h,c,l,a,o,n,t,i,u),e&&u&&(s.shapeOverlapKeeper.set(t.id,i.id),s.bodyOverlapKeeper.set(n.id,o.id))}}}}}sphereSphere(e,t,s,i,n,o,r,a,l,c,h){if(h)return s.distanceSquared(i)<(e.radius+t.radius)**2;const u=this.createContactEquation(r,a,e,t,l,c);i.vsub(s,u.ni),u.ni.normalize(),u.ri.copy(u.ni),u.rj.copy(u.ni),u.ri.scale(e.radius,u.ri),u.rj.scale(-t.radius,u.rj),u.ri.vadd(s,u.ri),u.ri.vsub(r.position,u.ri),u.rj.vadd(i,u.rj),u.rj.vsub(a.position,u.rj),this.result.push(u),this.createFrictionEquationsFromContact(u,this.frictionResult)}spherePlane(e,t,s,i,n,o,r,a,l,c,h){const u=this.createContactEquation(r,a,e,t,l,c);if(u.ni.set(0,0,1),o.vmult(u.ni,u.ni),u.ni.negate(u.ni),u.ni.normalize(),u.ni.scale(e.radius,u.ri),s.vsub(i,ms),u.ni.scale(u.ni.dot(ms),fs),ms.vsub(fs,u.rj),-ms.dot(u.ni)<=e.radius){if(h)return!0;const e=u.ri,t=u.rj;e.vadd(s,e),e.vsub(r.position,e),t.vadd(i,t),t.vsub(a.position,t),this.result.push(u),this.createFrictionEquationsFromContact(u,this.frictionResult)}}boxBox(e,t,s,i,n,o,r,a,l,c,h){return e.convexPolyhedronRepresentation.material=e.material,t.convexPolyhedronRepresentation.material=t.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexConvex(e.convexPolyhedronRepresentation,t.convexPolyhedronRepresentation,s,i,n,o,r,a,e,t,h)}sphereBox(e,t,s,i,n,o,r,a,l,c,h){const u=this.v3pool,d=Ts;s.vsub(i,xs),t.getSideNormals(d,o);const p=e.radius;let m=!1;const f=Ss,v=Ms,y=Cs;let g=null,w=0,x=0,A=0,b=null;for(let e=0,t=d.length;e!==t&&!1===m;e++){const t=As;t.copy(d[e]);const s=t.length();t.normalize();const i=xs.dot(t);if(i<s+p&&i>0){const n=bs,o=Es;n.copy(d[(e+1)%3]),o.copy(d[(e+2)%3]);const r=n.length(),a=o.length();n.normalize(),o.normalize();const l=xs.dot(n),c=xs.dot(o);if(l<r&&l>-r&&c<a&&c>-a){const e=Math.abs(i-s-p);if((null===b||e<b)&&(b=e,x=l,A=c,g=s,f.copy(t),v.copy(n),y.copy(o),w++,h))return!0}}}if(w){m=!0;const n=this.createContactEquation(r,a,e,t,l,c);f.scale(-p,n.ri),n.ni.copy(f),n.ni.negate(n.ni),f.scale(g,f),v.scale(x,v),f.vadd(v,f),y.scale(A,y),f.vadd(y,n.rj),n.ri.vadd(s,n.ri),n.ri.vsub(r.position,n.ri),n.rj.vadd(i,n.rj),n.rj.vsub(a.position,n.rj),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}let E=u.get();const T=Rs;for(let n=0;2!==n&&!m;n++)for(let o=0;2!==o&&!m;o++)for(let u=0;2!==u&&!m;u++)if(E.set(0,0,0),n?E.vadd(d[0],E):E.vsub(d[0],E),o?E.vadd(d[1],E):E.vsub(d[1],E),u?E.vadd(d[2],E):E.vsub(d[2],E),i.vadd(E,T),T.vsub(s,T),T.lengthSquared()<p*p){if(h)return!0;m=!0;const n=this.createContactEquation(r,a,e,t,l,c);n.ri.copy(T),n.ri.normalize(),n.ni.copy(n.ri),n.ri.scale(p,n.ri),n.rj.copy(E),n.ri.vadd(s,n.ri),n.ri.vsub(r.position,n.ri),n.rj.vadd(i,n.rj),n.rj.vsub(a.position,n.rj),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}u.release(E),E=null;const R=u.get(),S=u.get(),M=u.get(),C=u.get(),I=u.get(),N=d.length;for(let n=0;n!==N&&!m;n++)for(let o=0;o!==N&&!m;o++)if(n%3!=o%3){d[o].cross(d[n],R),R.normalize(),d[n].vadd(d[o],S),M.copy(s),M.vsub(S,M),M.vsub(i,M);const u=M.dot(R);R.scale(u,C);let f=0;for(;f===n%3||f===o%3;)f++;I.copy(s),I.vsub(C,I),I.vsub(S,I),I.vsub(i,I);const v=Math.abs(u),y=I.length();if(v<d[f].length()&&y<p){if(h)return!0;m=!0;const n=this.createContactEquation(r,a,e,t,l,c);S.vadd(C,n.rj),n.rj.copy(n.rj),I.negate(n.ni),n.ni.normalize(),n.ri.copy(n.rj),n.ri.vadd(i,n.ri),n.ri.vsub(s,n.ri),n.ri.normalize(),n.ri.scale(p,n.ri),n.ri.vadd(s,n.ri),n.ri.vsub(r.position,n.ri),n.rj.vadd(i,n.rj),n.rj.vsub(a.position,n.rj),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}u.release(R,S,M,C,I)}planeBox(e,t,s,i,n,o,r,a,l,c,h){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,t.convexPolyhedronRepresentation.id=t.id,this.planeConvex(e,t.convexPolyhedronRepresentation,s,i,n,o,r,a,e,t,h)}convexConvex(e,t,s,i,n,o,r,a,l,c,h,u,d){const p=Us;if(!(s.distanceTo(i)>e.boundingSphereRadius+t.boundingSphereRadius)&&e.findSeparatingAxis(t,s,n,i,o,p,u,d)){const u=[],d=Gs;e.clipAgainstHull(s,n,t,i,o,p,-100,100,u);let m=0;for(let n=0;n!==u.length;n++){if(h)return!0;const o=this.createContactEquation(r,a,e,t,l,c),f=o.ri,v=o.rj;p.negate(o.ni),u[n].normal.negate(d),d.scale(u[n].depth,d),u[n].point.vadd(d,f),v.copy(u[n].point),f.vsub(s,f),v.vsub(i,v),f.vadd(s,f),f.vsub(r.position,f),v.vadd(i,v),v.vsub(a.position,v),this.result.push(o),m++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(o,this.frictionResult)}this.enableFrictionReduction&&m&&this.createFrictionFromAverage(m)}}sphereConvex(e,t,s,i,n,o,r,a,l,c,h){const u=this.v3pool;s.vsub(i,Is);const d=t.faceNormals,p=t.faces,m=t.vertices,f=e.radius;let v=!1;for(let n=0;n!==m.length;n++){const u=m[n],d=Ps;o.vmult(u,d),i.vadd(d,d);const p=Fs;if(d.vsub(s,p),p.lengthSquared()<f*f){if(h)return!0;v=!0;const n=this.createContactEquation(r,a,e,t,l,c);return n.ri.copy(p),n.ri.normalize(),n.ni.copy(n.ri),n.ri.scale(f,n.ri),d.vsub(i,n.rj),n.ri.vadd(s,n.ri),n.ri.vsub(r.position,n.ri),n.rj.vadd(i,n.rj),n.rj.vsub(a.position,n.rj),this.result.push(n),void this.createFrictionEquationsFromContact(n,this.frictionResult)}}for(let n=0,y=p.length;n!==y&&!1===v;n++){const y=d[n],g=p[n],w=zs;o.vmult(y,w);const x=Bs;o.vmult(m[g[0]],x),x.vadd(i,x);const A=_s;w.scale(-f,A),s.vadd(A,A);const b=Os;A.vsub(x,b);const E=b.dot(w),T=ks;if(s.vsub(x,T),E<0&&T.dot(w)>0){const n=[];for(let e=0,t=g.length;e!==t;e++){const t=u.get();o.vmult(m[g[e]],t),i.vadd(t,t),n.push(t)}if(ws(n,w,s)){if(h)return!0;v=!0;const o=this.createContactEquation(r,a,e,t,l,c);w.scale(-f,o.ri),w.negate(o.ni);const d=u.get();w.scale(-E,d);const p=u.get();w.scale(-f,p),s.vsub(i,o.rj),o.rj.vadd(p,o.rj),o.rj.vadd(d,o.rj),o.rj.vadd(i,o.rj),o.rj.vsub(a.position,o.rj),o.ri.vadd(s,o.ri),o.ri.vsub(r.position,o.ri),u.release(d),u.release(p),this.result.push(o),this.createFrictionEquationsFromContact(o,this.frictionResult);for(let e=0,t=n.length;e!==t;e++)u.release(n[e]);return}for(let d=0;d!==g.length;d++){const p=u.get(),v=u.get();o.vmult(m[g[(d+1)%g.length]],p),o.vmult(m[g[(d+2)%g.length]],v),i.vadd(p,p),i.vadd(v,v);const y=Ns;v.vsub(p,y);const w=Ls;y.unit(w);const x=u.get(),A=u.get();s.vsub(p,A);const b=A.dot(w);w.scale(b,x),x.vadd(p,x);const E=u.get();if(x.vsub(s,E),b>0&&b*b<y.lengthSquared()&&E.lengthSquared()<f*f){if(h)return!0;const o=this.createContactEquation(r,a,e,t,l,c);x.vsub(i,o.rj),x.vsub(s,o.ni),o.ni.normalize(),o.ni.scale(f,o.ri),o.rj.vadd(i,o.rj),o.rj.vsub(a.position,o.rj),o.ri.vadd(s,o.ri),o.ri.vsub(r.position,o.ri),this.result.push(o),this.createFrictionEquationsFromContact(o,this.frictionResult);for(let e=0,t=n.length;e!==t;e++)u.release(n[e]);return u.release(p),u.release(v),u.release(x),u.release(E),void u.release(A)}u.release(p),u.release(v),u.release(x),u.release(E),u.release(A)}for(let e=0,t=n.length;e!==t;e++)u.release(n[e])}}}planeConvex(e,t,s,i,n,o,r,a,l,c,h){const u=js,d=qs;d.set(0,0,1),n.vmult(d,d);let p=0;const m=Hs;for(let n=0;n!==t.vertices.length;n++){u.copy(t.vertices[n]),o.vmult(u,u),i.vadd(u,u),u.vsub(s,m);if(d.dot(m)<=0){if(h)return!0;const n=this.createContactEquation(r,a,e,t,l,c),o=Ds;d.scale(d.dot(m),o),u.vsub(o,o),o.vsub(s,n.ri),n.ni.copy(d),u.vsub(i,n.rj),n.ri.vadd(s,n.ri),n.ri.vsub(r.position,n.ri),n.rj.vadd(i,n.rj),n.rj.vsub(a.position,n.rj),this.result.push(n),p++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(n,this.frictionResult)}}this.enableFrictionReduction&&p&&this.createFrictionFromAverage(p)}boxConvex(e,t,s,i,n,o,r,a,l,c,h){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexConvex(e.convexPolyhedronRepresentation,t,s,i,n,o,r,a,e,t,h)}sphereHeightfield(e,t,s,i,n,o,r,a,l,c,h){const u=t.data,d=e.radius,p=t.elementSize,m=ni,f=ii;g.pointToLocalFrame(i,o,s,f);let v=Math.floor((f.x-d)/p)-1,y=Math.ceil((f.x+d)/p)+1,w=Math.floor((f.y-d)/p)-1,x=Math.ceil((f.y+d)/p)+1;if(y<0||x<0||v>u.length||w>u[0].length)return;v<0&&(v=0),y<0&&(y=0),w<0&&(w=0),x<0&&(x=0),v>=u.length&&(v=u.length-1),y>=u.length&&(y=u.length-1),x>=u[0].length&&(x=u[0].length-1),w>=u[0].length&&(w=u[0].length-1);const A=[];t.getRectMinMax(v,w,y,x,A);const b=A[0],E=A[1];if(f.z-d>E||f.z+d<b)return;const T=this.result;for(let l=v;l<y;l++)for(let c=w;c<x;c++){const u=T.length;let d=!1;if(t.getConvexTrianglePillar(l,c,!1),g.pointToWorldFrame(i,o,t.pillarOffset,m),s.distanceTo(m)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(d=this.sphereConvex(e,t.pillarConvex,s,m,n,o,r,a,e,t,h)),h&&d)return!0;if(t.getConvexTrianglePillar(l,c,!0),g.pointToWorldFrame(i,o,t.pillarOffset,m),s.distanceTo(m)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(d=this.sphereConvex(e,t.pillarConvex,s,m,n,o,r,a,e,t,h)),h&&d)return!0;if(T.length-u>2)return}}boxHeightfield(e,t,s,i,n,o,r,a,l,c,h){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexHeightfield(e.convexPolyhedronRepresentation,t,s,i,n,o,r,a,e,t,h)}convexHeightfield(e,t,s,i,n,o,r,a,l,c,h){const u=t.data,d=t.elementSize,p=e.boundingSphereRadius,m=ti,f=si,v=ei;g.pointToLocalFrame(i,o,s,v);let y=Math.floor((v.x-p)/d)-1,w=Math.ceil((v.x+p)/d)+1,x=Math.floor((v.y-p)/d)-1,A=Math.ceil((v.y+p)/d)+1;if(w<0||A<0||y>u.length||x>u[0].length)return;y<0&&(y=0),w<0&&(w=0),x<0&&(x=0),A<0&&(A=0),y>=u.length&&(y=u.length-1),w>=u.length&&(w=u.length-1),A>=u[0].length&&(A=u[0].length-1),x>=u[0].length&&(x=u[0].length-1);const b=[];t.getRectMinMax(y,x,w,A,b);const E=b[0],T=b[1];if(!(v.z-p>T||v.z+p<E))for(let l=y;l<w;l++)for(let c=x;c<A;c++){let u=!1;if(t.getConvexTrianglePillar(l,c,!1),g.pointToWorldFrame(i,o,t.pillarOffset,m),s.distanceTo(m)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(u=this.convexConvex(e,t.pillarConvex,s,m,n,o,r,a,null,null,h,f,null)),h&&u)return!0;if(t.getConvexTrianglePillar(l,c,!0),g.pointToWorldFrame(i,o,t.pillarOffset,m),s.distanceTo(m)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(u=this.convexConvex(e,t.pillarConvex,s,m,n,o,r,a,null,null,h,f,null)),h&&u)return!0}}sphereParticle(e,t,s,i,n,o,r,a,l,c,h){const u=Xs;u.set(0,0,1),i.vsub(s,u);if(u.lengthSquared()<=e.radius*e.radius){if(h)return!0;const s=this.createContactEquation(a,r,t,e,l,c);u.normalize(),s.rj.copy(u),s.rj.scale(e.radius,s.rj),s.ni.copy(u),s.ni.negate(s.ni),s.ri.set(0,0,0),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult)}}planeParticle(e,t,s,i,n,o,r,a,l,c,h){const u=Vs;u.set(0,0,1),r.quaternion.vmult(u,u);const d=Ws;i.vsub(r.position,d);if(u.dot(d)<=0){if(h)return!0;const s=this.createContactEquation(a,r,t,e,l,c);s.ni.copy(u),s.ni.negate(s.ni),s.ri.set(0,0,0);const n=Ks;u.scale(u.dot(i),n),i.vsub(n,n),s.rj.copy(n),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult)}}boxParticle(e,t,s,i,n,o,r,a,l,c,h){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexParticle(e.convexPolyhedronRepresentation,t,s,i,n,o,r,a,e,t,h)}convexParticle(e,t,s,i,n,o,r,a,l,c,h){let u=-1;const d=Qs,p=$s;let m=null;const f=Zs;if(f.copy(i),f.vsub(s,f),n.conjugate(Ys),Ys.vmult(f,f),e.pointIsInside(f)){e.worldVerticesNeedsUpdate&&e.computeWorldVertices(s,n),e.worldFaceNormalsNeedsUpdate&&e.computeWorldFaceNormals(n);for(let t=0,s=e.faces.length;t!==s;t++){const s=[e.worldVertices[e.faces[t][0]]],n=e.worldFaceNormals[t];i.vsub(s[0],Js);const o=-n.dot(Js);if(null===m||Math.abs(o)<Math.abs(m)){if(h)return!0;m=o,u=t,d.copy(n)}}if(-1!==u){const n=this.createContactEquation(a,r,t,e,l,c);d.scale(m,p),p.vadd(i,p),p.vsub(s,p),n.rj.copy(p),d.negate(n.ni),n.ri.set(0,0,0);const o=n.ri,h=n.rj;o.vadd(i,o),o.vsub(a.position,o),h.vadd(s,h),h.vsub(r.position,h),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}}heightfieldCylinder(e,t,s,i,n,o,r,a,l,c,h){return this.convexHeightfield(t,e,i,s,o,n,a,r,l,c,h)}particleCylinder(e,t,s,i,n,o,r,a,l,c,h){return this.convexParticle(t,e,i,s,o,n,a,r,l,c,h)}sphereTrimesh(e,t,s,i,n,o,r,a,l,c,h){const u=is,d=ns,p=os,m=rs,f=as,v=ls,y=ds,w=ss,x=es,A=ps;g.pointToLocalFrame(i,o,s,f);const b=e.radius;y.lowerBound.set(f.x-b,f.y-b,f.z-b),y.upperBound.set(f.x+b,f.y+b,f.z+b),t.getTrianglesInAABB(y,A);const E=ts,T=e.radius*e.radius;for(let n=0;n<A.length;n++)for(let u=0;u<3;u++)if(t.getVertex(t.indices[3*A[n]+u],E),E.vsub(f,x),x.lengthSquared()<=T){if(w.copy(E),g.pointToWorldFrame(i,o,w,E),E.vsub(s,x),h)return!0;let n=this.createContactEquation(r,a,e,t,l,c);n.ni.copy(x),n.ni.normalize(),n.ri.copy(n.ni),n.ri.scale(e.radius,n.ri),n.ri.vadd(s,n.ri),n.ri.vsub(r.position,n.ri),n.rj.copy(E),n.rj.vsub(a.position,n.rj),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}for(let n=0;n<A.length;n++)for(let y=0;y<3;y++){t.getVertex(t.indices[3*A[n]+y],u),t.getVertex(t.indices[3*A[n]+(y+1)%3],d),d.vsub(u,p),f.vsub(d,v);const w=v.dot(p);f.vsub(u,v);let x=v.dot(p);if(x>0&&w<0){f.vsub(u,v),m.copy(p),m.normalize(),x=v.dot(m),m.scale(x,v),v.vadd(u,v);if(v.distanceTo(f)<e.radius){if(h)return!0;const n=this.createContactEquation(r,a,e,t,l,c);v.vsub(f,n.ni),n.ni.normalize(),n.ni.scale(e.radius,n.ri),n.ri.vadd(s,n.ri),n.ri.vsub(r.position,n.ri),g.pointToWorldFrame(i,o,v,v),v.vsub(a.position,n.rj),g.vectorToWorldFrame(o,n.ni,n.ni),g.vectorToWorldFrame(o,n.ri,n.ri),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}}const R=cs,S=hs,M=us,C=$t;for(let n=0,u=A.length;n!==u;n++){t.getTriangleVertices(A[n],R,S,M),t.getNormal(A[n],C),f.vsub(R,v);let u=v.dot(C);if(C.scale(u,v),f.vsub(v,v),u=v.distanceTo(f),ue.pointInTriangle(v,R,S,M)&&u<e.radius){if(h)return!0;let n=this.createContactEquation(r,a,e,t,l,c);v.vsub(f,n.ni),n.ni.normalize(),n.ni.scale(e.radius,n.ri),n.ri.vadd(s,n.ri),n.ri.vsub(r.position,n.ri),g.pointToWorldFrame(i,o,v,v),v.vsub(a.position,n.rj),g.vectorToWorldFrame(o,n.ni,n.ni),g.vectorToWorldFrame(o,n.ri,n.ri),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}A.length=0}planeTrimesh(e,t,s,i,n,r,a,l,c,h,u){const d=new o,p=Zt;p.set(0,0,1),n.vmult(p,p);for(let n=0;n<t.vertices.length/3;n++){t.getVertex(n,d);const m=new o;m.copy(d),g.pointToWorldFrame(i,r,m,d);const f=Qt;d.vsub(s,f);if(p.dot(f)<=0){if(u)return!0;const s=this.createContactEquation(a,l,e,t,c,h);s.ni.copy(p);const i=Jt;p.scale(f.dot(p),i),d.vsub(i,i),s.ri.copy(i),s.ri.vsub(a.position,s.ri),s.rj.copy(d),s.rj.vsub(l.position,s.rj),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult)}}}}const Ut=new o,Gt=new o,Vt=new o,Wt=new o,Kt=new o,Xt=new m,Yt=new m,Zt=new o,Qt=new o,Jt=new o,$t=new o,es=new o;new o;const ts=new o,ss=new o,is=new o,ns=new o,os=new o,rs=new o,as=new o,ls=new o,cs=new o,hs=new o,us=new o,ds=new c,ps=[],ms=new o,fs=new o,vs=new o,ys=new o,gs=new o;function ws(e,t,s){let i=null;const n=e.length;for(let o=0;o!==n;o++){const r=e[o],a=vs;e[(o+1)%n].vsub(r,a);const l=ys;a.cross(t,l);const c=gs;s.vsub(r,c);const h=l.dot(c);if(!(null===i||h>0&&!0===i||h<=0&&!1===i))return!1;null===i&&(i=h>0)}return!0}const xs=new o,As=new o,bs=new o,Es=new o,Ts=[new o,new o,new o,new o,new o,new o],Rs=new o,Ss=new o,Ms=new o,Cs=new o,Is=new o,Ns=new o,Ls=new o,Fs=new o,Ps=new o,zs=new o,Bs=new o,_s=new o,Os=new o,ks=new o;new o,new o;const js=new o,qs=new o,Hs=new o,Ds=new o,Us=new o,Gs=new o,Vs=new o,Ws=new o,Ks=new o,Xs=new o,Ys=new m,Zs=new o;new o;const Qs=new o,Js=new o,$s=new o,ei=new o,ti=new o,si=[0],ii=new o,ni=new o;class oi{constructor(){this.current=[],this.previous=[]}getKey(e,t){if(t<e){const s=t;t=e,e=s}return e<<16|t}set(e,t){const s=this.getKey(e,t),i=this.current;let n=0;for(;s>i[n];)n++;if(s!==i[n]){for(let e=i.length-1;e>=n;e--)i[e+1]=i[e];i[n]=s}}tick(){const e=this.current;this.current=this.previous,this.previous=e,this.current.length=0}getDiff(e,t){const s=this.current,i=this.previous,n=s.length,o=i.length;let r=0;for(let t=0;t<n;t++){let n=!1;const o=s[t];for(;o>i[r];)r++;n=o===i[r],n||ri(e,o)}r=0;for(let e=0;e<o;e++){let n=!1;const o=i[e];for(;o>s[r];)r++;n=s[r]===o,n||ri(t,o)}}}function ri(e,t){e.push((4294901760&t)>>16,65535&t)}const ai=(e,t)=>e<t?"".concat(e,"-").concat(t):"".concat(t,"-").concat(e);class li{constructor(){this.data={keys:[]}}get(e,t){const s=ai(e,t);return this.data[s]}set(e,t,s){const i=ai(e,t);this.get(e,t)||this.data.keys.push(i),this.data[i]=s}delete(e,t){const s=ai(e,t),i=this.data.keys.indexOf(s);-1!==i&&this.data.keys.splice(i,1),delete this.data[s]}reset(){const e=this.data,t=e.keys;for(;t.length>0;){delete e[t.pop()]}}}class ci extends p{constructor(e){void 0===e&&(e={}),super(),this.dt=-1,this.allowSleep=!!e.allowSleep,this.contacts=[],this.frictionEquations=[],this.quatNormalizeSkip=void 0!==e.quatNormalizeSkip?e.quatNormalizeSkip:0,this.quatNormalizeFast=void 0!==e.quatNormalizeFast&&e.quatNormalizeFast,this.time=0,this.stepnumber=0,this.default_dt=1/60,this.nextId=0,this.gravity=new o,e.gravity&&this.gravity.copy(e.gravity),e.frictionGravity&&(this.frictionGravity=new o,this.frictionGravity.copy(e.frictionGravity)),this.broadphase=void 0!==e.broadphase?e.broadphase:new $,this.bodies=[],this.hasActiveBodies=!1,this.solver=void 0!==e.solver?e.solver:new ut,this.constraints=[],this.narrowphase=new Dt(this),this.collisionMatrix=new d,this.collisionMatrixPrevious=new d,this.bodyOverlapKeeper=new oi,this.shapeOverlapKeeper=new oi,this.contactmaterials=[],this.contactMaterialTable=new li,this.defaultMaterial=new ct("default"),this.defaultContactMaterial=new lt(this.defaultMaterial,this.defaultMaterial,{friction:.3,restitution:0}),this.doProfiling=!1,this.profile={solve:0,makeContactConstraints:0,broadphase:0,integrate:0,narrowphase:0},this.accumulator=0,this.subsystems=[],this.addBodyEvent={type:"addBody",body:null},this.removeBodyEvent={type:"removeBody",body:null},this.idToBodyMap={},this.broadphase.setWorld(this)}getContactMaterial(e,t){return this.contactMaterialTable.get(e.id,t.id)}collisionMatrixTick(){const e=this.collisionMatrixPrevious;this.collisionMatrixPrevious=this.collisionMatrix,this.collisionMatrix=e,this.collisionMatrix.reset(),this.bodyOverlapKeeper.tick(),this.shapeOverlapKeeper.tick()}addConstraint(e){this.constraints.push(e)}removeConstraint(e){const t=this.constraints.indexOf(e);-1!==t&&this.constraints.splice(t,1)}rayTest(e,t,s){s instanceof ee?this.raycastClosest(e,t,{skipBackfaces:!0},s):this.raycastAll(e,t,{skipBackfaces:!0},s)}raycastAll(e,t,s,i){return void 0===s&&(s={}),s.mode=ue.ALL,s.from=e,s.to=t,s.callback=i,hi.intersectWorld(this,s)}raycastAny(e,t,s,i){return void 0===s&&(s={}),s.mode=ue.ANY,s.from=e,s.to=t,s.result=i,hi.intersectWorld(this,s)}raycastClosest(e,t,s,i){return void 0===s&&(s={}),s.mode=ue.CLOSEST,s.from=e,s.to=t,s.result=i,hi.intersectWorld(this,s)}addBody(e){this.bodies.includes(e)||(e.index=this.bodies.length,this.bodies.push(e),e.world=this,e.initPosition.copy(e.position),e.initVelocity.copy(e.velocity),e.timeLastSleepy=this.time,e instanceof z&&(e.initAngularVelocity.copy(e.angularVelocity),e.initQuaternion.copy(e.quaternion)),this.collisionMatrix.setNumObjects(this.bodies.length),this.addBodyEvent.body=e,this.idToBodyMap[e.id]=e,this.dispatchEvent(this.addBodyEvent))}removeBody(e){e.world=null;const t=this.bodies.length-1,s=this.bodies,i=s.indexOf(e);if(-1!==i){s.splice(i,1);for(let e=0;e!==s.length;e++)s[e].index=e;this.collisionMatrix.setNumObjects(t),this.removeBodyEvent.body=e,delete this.idToBodyMap[e.id],this.dispatchEvent(this.removeBodyEvent)}}getBodyById(e){return this.idToBodyMap[e]}getShapeById(e){const t=this.bodies;for(let s=0;s<t.length;s++){const i=t[s].shapes;for(let t=0;t<i.length;t++){const s=i[t];if(s.id===e)return s}}return null}addContactMaterial(e){this.contactmaterials.push(e),this.contactMaterialTable.set(e.materials[0].id,e.materials[1].id,e)}removeContactMaterial(e){const t=this.contactmaterials.indexOf(e);-1!==t&&(this.contactmaterials.splice(t,1),this.contactMaterialTable.delete(e.materials[0].id,e.materials[1].id))}fixedStep(e,t){void 0===e&&(e=1/60),void 0===t&&(t=10);const s=ui.now()/1e3;if(this.lastCallTime){const i=s-this.lastCallTime;this.step(e,i,t)}else this.step(e,void 0,t);this.lastCallTime=s}step(e,t,s){if(void 0===s&&(s=10),void 0===t)this.internalStep(e),this.time+=e;else{this.accumulator+=t;const i=ui.now();let n=0;for(;this.accumulator>=e&&n<s&&(this.internalStep(e),this.accumulator-=e,n++,!(ui.now()-i>1e3*e)););this.accumulator=this.accumulator%e;const o=this.accumulator/e;for(let e=0;e!==this.bodies.length;e++){const t=this.bodies[e];t.previousPosition.lerp(t.position,o,t.interpolatedPosition),t.previousQuaternion.slerp(t.quaternion,o,t.interpolatedQuaternion),t.previousQuaternion.normalize()}this.time+=t}}internalStep(e){this.dt=e;const t=this.contacts,s=yi,i=gi,n=this.bodies.length,o=this.bodies,r=this.solver,a=this.gravity,l=this.doProfiling,c=this.profile,h=z.DYNAMIC;let u=-1/0;const d=this.constraints,p=vi;a.length();const m=a.x,f=a.y,v=a.z;let y=0;for(l&&(u=ui.now()),y=0;y!==n;y++){const e=o[y];if(e.type===h){const t=e.force,s=e.mass;t.x+=s*m,t.y+=s*f,t.z+=s*v}}for(let e=0,t=this.subsystems.length;e!==t;e++)this.subsystems[e].update();l&&(u=ui.now()),s.length=0,i.length=0,this.broadphase.collisionPairs(this,s,i),l&&(c.broadphase=ui.now()-u);let g=d.length;for(y=0;y!==g;y++){const e=d[y];if(!e.collideConnected)for(let t=s.length-1;t>=0;t-=1)(e.bodyA===s[t]&&e.bodyB===i[t]||e.bodyB===s[t]&&e.bodyA===i[t])&&(s.splice(t,1),i.splice(t,1))}this.collisionMatrixTick(),l&&(u=ui.now());const w=fi,x=t.length;for(y=0;y!==x;y++)w.push(t[y]);t.length=0;const A=this.frictionEquations.length;for(y=0;y!==A;y++)p.push(this.frictionEquations[y]);for(this.frictionEquations.length=0,this.narrowphase.getContacts(s,i,this,t,w,this.frictionEquations,p),l&&(c.narrowphase=ui.now()-u),l&&(u=ui.now()),y=0;y<this.frictionEquations.length;y++)r.addEquation(this.frictionEquations[y]);const b=t.length;for(let e=0;e!==b;e++){const s=t[e],i=s.bi,n=s.bj,o=s.si,a=s.sj;let l;if(l=i.material&&n.material&&this.getContactMaterial(i.material,n.material)||this.defaultContactMaterial,l.friction,i.material&&n.material&&(i.material.friction>=0&&n.material.friction>=0&&(i.material.friction,n.material.friction),i.material.restitution>=0&&n.material.restitution>=0&&(s.restitution=i.material.restitution*n.material.restitution)),r.addEquation(s),i.allowSleep&&i.type===z.DYNAMIC&&i.sleepState===z.SLEEPING&&n.sleepState===z.AWAKE&&n.type!==z.STATIC){n.velocity.lengthSquared()+n.angularVelocity.lengthSquared()>=2*n.sleepSpeedLimit**2&&(i.wakeUpAfterNarrowphase=!0)}if(n.allowSleep&&n.type===z.DYNAMIC&&n.sleepState===z.SLEEPING&&i.sleepState===z.AWAKE&&i.type!==z.STATIC){i.velocity.lengthSquared()+i.angularVelocity.lengthSquared()>=2*i.sleepSpeedLimit**2&&(n.wakeUpAfterNarrowphase=!0)}this.collisionMatrix.set(i,n,!0),this.collisionMatrixPrevious.get(i,n)||(mi.body=n,mi.contact=s,i.dispatchEvent(mi),mi.body=i,n.dispatchEvent(mi)),this.bodyOverlapKeeper.set(i.id,n.id),this.shapeOverlapKeeper.set(o.id,a.id)}for(this.emitContactEvents(),l&&(c.makeContactConstraints=ui.now()-u,u=ui.now()),y=0;y!==n;y++){const e=o[y];e.wakeUpAfterNarrowphase&&(e.wakeUp(),e.wakeUpAfterNarrowphase=!1)}for(g=d.length,y=0;y!==g;y++){const e=d[y];e.update();for(let t=0,s=e.equations.length;t!==s;t++){const s=e.equations[t];r.addEquation(s)}}r.solve(e,this),l&&(c.solve=ui.now()-u),r.removeAllEquations();const E=Math.pow;for(y=0;y!==n;y++){const t=o[y];if(t.type&h){const s=E(1-t.linearDamping,e),i=t.velocity;i.scale(s,i);const n=t.angularVelocity;if(n){const s=E(1-t.angularDamping,e);n.scale(s,n)}}}this.dispatchEvent(pi),l&&(u=ui.now());const T=this.stepnumber%(this.quatNormalizeSkip+1)==0,R=this.quatNormalizeFast;for(y=0;y!==n;y++)o[y].integrate(e,T,R);this.clearForces(),this.broadphase.dirty=!0,l&&(c.integrate=ui.now()-u),this.stepnumber+=1,this.dispatchEvent(di);let S=!0;if(this.allowSleep)for(S=!1,y=0;y!==n;y++){const e=o[y];e.sleepTick(this.time),e.sleepState!==z.SLEEPING&&(S=!0)}this.hasActiveBodies=S}emitContactEvents(){const e=this.hasAnyEventListener("beginContact"),t=this.hasAnyEventListener("endContact");if((e||t)&&this.bodyOverlapKeeper.getDiff(wi,xi),e){for(let e=0,t=wi.length;e<t;e+=2)Ai.bodyA=this.getBodyById(wi[e]),Ai.bodyB=this.getBodyById(wi[e+1]),this.dispatchEvent(Ai);Ai.bodyA=Ai.bodyB=null}if(t){for(let e=0,t=xi.length;e<t;e+=2)bi.bodyA=this.getBodyById(xi[e]),bi.bodyB=this.getBodyById(xi[e+1]),this.dispatchEvent(bi);bi.bodyA=bi.bodyB=null}wi.length=xi.length=0;const s=this.hasAnyEventListener("beginShapeContact"),i=this.hasAnyEventListener("endShapeContact");if((s||i)&&this.shapeOverlapKeeper.getDiff(wi,xi),s){for(let e=0,t=wi.length;e<t;e+=2){const t=this.getShapeById(wi[e]),s=this.getShapeById(wi[e+1]);Ei.shapeA=t,Ei.shapeB=s,t&&(Ei.bodyA=t.body),s&&(Ei.bodyB=s.body),this.dispatchEvent(Ei)}Ei.bodyA=Ei.bodyB=Ei.shapeA=Ei.shapeB=null}if(i){for(let e=0,t=xi.length;e<t;e+=2){const t=this.getShapeById(xi[e]),s=this.getShapeById(xi[e+1]);Ti.shapeA=t,Ti.shapeB=s,t&&(Ti.bodyA=t.body),s&&(Ti.bodyB=s.body),this.dispatchEvent(Ti)}Ti.bodyA=Ti.bodyB=Ti.shapeA=Ti.shapeB=null}}clearForces(){const e=this.bodies,t=e.length;for(let s=0;s!==t;s++){const t=e[s];t.force,t.torque,t.force.set(0,0,0),t.torque.set(0,0,0)}}}new c;const hi=new ue,ui=globalThis.performance||{};if(!ui.now){let e=Date.now();ui.timing&&ui.timing.navigationStart&&(e=ui.timing.navigationStart),ui.now=()=>Date.now()-e}new o;const di={type:"postStep"},pi={type:"preStep"},mi={type:z.COLLIDE_EVENT_NAME,body:null,contact:null},fi=[],vi=[],yi=[],gi=[],wi=[],xi=[],Ai={type:"beginContact",bodyA:null,bodyB:null},bi={type:"endContact",bodyA:null,bodyB:null},Ei={type:"beginShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},Ti={type:"endShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null}},743:(e,t,s)=>{s.d(t,{o:()=>a});var i=s(4599);const n=new i.Pa4,o=new i.$V,r=new i.Pa4;class a{constructor(e,t){this.object=e,this.domElement=t,this.enabled=!0,this.movementSpeed=1,this.lookSpeed=.005,this.lookVertical=!0,this.autoForward=!1,this.activeLook=!0,this.heightSpeed=!1,this.heightCoef=1,this.heightMin=0,this.heightMax=1,this.constrainVertical=!1,this.verticalMin=0,this.verticalMax=Math.PI,this.mouseDragOn=!1,this.autoSpeedFactor=0,this.pointerX=0,this.pointerY=0,this.moveForward=!1,this.moveBackward=!1,this.moveLeft=!1,this.moveRight=!1,this.viewHalfX=0,this.viewHalfY=0;let s=0,a=0;this.handleResize=function(){this.domElement===document?(this.viewHalfX=window.innerWidth/2,this.viewHalfY=window.innerHeight/2):(this.viewHalfX=this.domElement.offsetWidth/2,this.viewHalfY=this.domElement.offsetHeight/2)},this.onPointerDown=function(e){if(this.domElement!==document&&this.domElement.focus(),this.activeLook)switch(e.button){case 0:this.moveForward=!0;break;case 2:this.moveBackward=!0}this.mouseDragOn=!0},this.onPointerUp=function(e){if(this.activeLook)switch(e.button){case 0:this.moveForward=!1;break;case 2:this.moveBackward=!1}this.mouseDragOn=!1},this.onPointerMove=function(e){this.domElement===document?(this.pointerX=e.pageX-this.viewHalfX,this.pointerY=e.pageY-this.viewHalfY):(this.pointerX=e.pageX-this.domElement.offsetLeft-this.viewHalfX,this.pointerY=e.pageY-this.domElement.offsetTop-this.viewHalfY)},this.onKeyDown=function(e){switch(e.code){case"ArrowUp":case"KeyW":this.moveForward=!0;break;case"ArrowLeft":case"KeyA":this.moveLeft=!0;break;case"ArrowDown":case"KeyS":this.moveBackward=!0;break;case"ArrowRight":case"KeyD":this.moveRight=!0;break;case"KeyR":this.moveUp=!0;break;case"KeyF":this.moveDown=!0}},this.onKeyUp=function(e){switch(e.code){case"ArrowUp":case"KeyW":this.moveForward=!1;break;case"ArrowLeft":case"KeyA":this.moveLeft=!1;break;case"ArrowDown":case"KeyS":this.moveBackward=!1;break;case"ArrowRight":case"KeyD":this.moveRight=!1;break;case"KeyR":this.moveUp=!1;break;case"KeyF":this.moveDown=!1}},this.lookAt=function(e,t,s){return e.isVector3?r.copy(e):r.set(e,t,s),this.object.lookAt(r),m(this),this},this.update=function(){const e=new i.Pa4;return function(t){if(!1===this.enabled)return;if(this.heightSpeed){const e=i.M8C.clamp(this.object.position.y,this.heightMin,this.heightMax)-this.heightMin;this.autoSpeedFactor=t*(e*this.heightCoef)}else this.autoSpeedFactor=0;const n=t*this.movementSpeed;(this.moveForward||this.autoForward&&!this.moveBackward)&&this.object.translateZ(-(n+this.autoSpeedFactor)),this.moveBackward&&this.object.translateZ(n),this.moveLeft&&this.object.translateX(-n),this.moveRight&&this.object.translateX(n),this.moveUp&&this.object.translateY(n),this.moveDown&&this.object.translateY(-n);let o=t*this.lookSpeed;this.activeLook||(o=0);let r=1;this.constrainVertical&&(r=Math.PI/(this.verticalMax-this.verticalMin)),a-=this.pointerX*o,this.lookVertical&&(s-=this.pointerY*o*r),s=Math.max(-85,Math.min(85,s));let l=i.M8C.degToRad(90-s);const c=i.M8C.degToRad(a);this.constrainVertical&&(l=i.M8C.mapLinear(l,0,Math.PI,this.verticalMin,this.verticalMax));const h=this.object.position;e.setFromSphericalCoords(1,l,c).add(h),this.object.lookAt(e)}}(),this.dispose=function(){this.domElement.removeEventListener("contextmenu",l),this.domElement.removeEventListener("pointerdown",h),this.domElement.removeEventListener("pointermove",c),this.domElement.removeEventListener("pointerup",u),window.removeEventListener("keydown",d),window.removeEventListener("keyup",p)};const c=this.onPointerMove.bind(this),h=this.onPointerDown.bind(this),u=this.onPointerUp.bind(this),d=this.onKeyDown.bind(this),p=this.onKeyUp.bind(this);function m(e){const t=e.object.quaternion;n.set(0,0,-1).applyQuaternion(t),o.setFromVector3(n),s=90-i.M8C.radToDeg(o.phi),a=i.M8C.radToDeg(o.theta)}this.domElement.addEventListener("contextmenu",l),this.domElement.addEventListener("pointerdown",h),this.domElement.addEventListener("pointermove",c),this.domElement.addEventListener("pointerup",u),window.addEventListener("keydown",d),window.addEventListener("keyup",p),this.handleResize(),m(this)}}function l(e){e.preventDefault()}},195:(e,t,s)=>{s.d(t,{E:()=>o});var i=s(4599);function n(e,t){if(t===i.WwZ)return e;if(t===i.z$h||t===i.UlW){let s=e.getIndex();if(null===s){const t=[],i=e.getAttribute("position");if(void 0===i)return e;for(let e=0;e<i.count;e++)t.push(e);e.setIndex(t),s=e.getIndex()}const n=s.count-2,o=[];if(t===i.z$h)for(let e=1;e<=n;e++)o.push(s.getX(0)),o.push(s.getX(e)),o.push(s.getX(e+1));else for(let e=0;e<n;e++)e%2==0?(o.push(s.getX(e)),o.push(s.getX(e+1)),o.push(s.getX(e+2))):(o.push(s.getX(e+2)),o.push(s.getX(e+1)),o.push(s.getX(e)));o.length;const r=e.clone();return r.setIndex(o),r.clearGroups(),r}return e}class o extends i.aNw{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register((function(e){return new u(e)})),this.register((function(e){return new w(e)})),this.register((function(e){return new x(e)})),this.register((function(e){return new A(e)})),this.register((function(e){return new p(e)})),this.register((function(e){return new m(e)})),this.register((function(e){return new f(e)})),this.register((function(e){return new v(e)})),this.register((function(e){return new h(e)})),this.register((function(e){return new y(e)})),this.register((function(e){return new d(e)})),this.register((function(e){return new g(e)})),this.register((function(e){return new l(e)})),this.register((function(e){return new b(e)})),this.register((function(e){return new E(e)}))}load(e,t,s,n){const o=this;let r;r=""!==this.resourcePath?this.resourcePath:""!==this.path?this.path:i.Zp0.extractUrlBase(e),this.manager.itemStart(e);const a=function(t){n&&n(t),o.manager.itemError(e),o.manager.itemEnd(e)},l=new i.hH6(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(e,(function(s){try{o.parse(s,r,(function(s){t(s),o.manager.itemEnd(e)}),a)}catch(e){a(e)}}),s,a)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return-1===this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.push(e),this}unregister(e){return-1!==this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,s,i){let n;const o={},r={},l=new TextDecoder;if("string"==typeof e)n=JSON.parse(e);else if(e instanceof ArrayBuffer){if(l.decode(new Uint8Array(e,0,4))===T){try{o[a.KHR_BINARY_GLTF]=new M(e)}catch(e){return void(i&&i(e))}n=JSON.parse(o[a.KHR_BINARY_GLTF].content)}else n=JSON.parse(l.decode(e))}else n=e;if(void 0===n.asset||n.asset.version[0]<2)return void(i&&i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));const h=new J(n,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});h.fileLoader.setRequestHeader(this.requestHeader);for(let e=0;e<this.pluginCallbacks.length;e++){const t=this.pluginCallbacks[e](h);r[t.name]=t,o[t.name]=!0}if(n.extensionsUsed)for(let e=0;e<n.extensionsUsed.length;++e){const t=n.extensionsUsed[e],s=n.extensionsRequired||[];switch(t){case a.KHR_MATERIALS_UNLIT:o[t]=new c;break;case a.KHR_DRACO_MESH_COMPRESSION:o[t]=new C(n,this.dracoLoader);break;case a.KHR_TEXTURE_TRANSFORM:o[t]=new I;break;case a.KHR_MESH_QUANTIZATION:o[t]=new N;break;default:s.indexOf(t)>=0&&r[t]}}h.setExtensions(o),h.setPlugins(r),h.parse(s,i)}parseAsync(e,t){const s=this;return new Promise((function(i,n){s.parse(e,t,i,n)}))}}function r(){let e={};return{get:function(t){return e[t]},add:function(t,s){e[t]=s},remove:function(t){delete e[t]},removeAll:function(){e={}}}}const a={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class l{constructor(e){this.parser=e,this.name=a.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let s=0,i=t.length;s<i;s++){const i=t[s];i.extensions&&i.extensions[this.name]&&void 0!==i.extensions[this.name].light&&e._addNodeRef(this.cache,i.extensions[this.name].light)}}_loadLight(e){const t=this.parser,s="light:"+e;let n=t.cache.get(s);if(n)return n;const o=t.json,r=((o.extensions&&o.extensions[this.name]||{}).lights||[])[e];let a;const l=new i.Ilk(16777215);void 0!==r.color&&l.setRGB(r.color[0],r.color[1],r.color[2],i.GUF);const c=void 0!==r.range?r.range:0;switch(r.type){case"directional":a=new i.Ox3(l),a.target.position.set(0,0,-1),a.add(a.target);break;case"point":a=new i.cek(l),a.distance=c;break;case"spot":a=new i.PMe(l),a.distance=c,r.spot=r.spot||{},r.spot.innerConeAngle=void 0!==r.spot.innerConeAngle?r.spot.innerConeAngle:0,r.spot.outerConeAngle=void 0!==r.spot.outerConeAngle?r.spot.outerConeAngle:Math.PI/4,a.angle=r.spot.outerConeAngle,a.penumbra=1-r.spot.innerConeAngle/r.spot.outerConeAngle,a.target.position.set(0,0,-1),a.add(a.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+r.type)}return a.position.set(0,0,0),a.decay=2,W(a,r),void 0!==r.intensity&&(a.intensity=r.intensity),a.name=t.createUniqueName(r.name||"light_"+e),n=Promise.resolve(a),t.cache.add(s,n),n}getDependency(e,t){if("light"===e)return this._loadLight(t)}createNodeAttachment(e){const t=this,s=this.parser,i=s.json.nodes[e],n=(i.extensions&&i.extensions[this.name]||{}).light;return void 0===n?null:this._loadLight(n).then((function(e){return s._getNodeRef(t.cache,n,e)}))}}class c{constructor(){this.name=a.KHR_MATERIALS_UNLIT}getMaterialType(){return i.vBJ}extendParams(e,t,s){const n=[];e.color=new i.Ilk(1,1,1),e.opacity=1;const o=t.pbrMetallicRoughness;if(o){if(Array.isArray(o.baseColorFactor)){const t=o.baseColorFactor;e.color.setRGB(t[0],t[1],t[2],i.GUF),e.opacity=t[3]}void 0!==o.baseColorTexture&&n.push(s.assignTexture(e,"map",o.baseColorTexture,i.KI_))}return Promise.all(n)}}class h{constructor(e){this.parser=e,this.name=a.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const s=this.parser.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=s.extensions[this.name].emissiveStrength;return void 0!==i&&(t.emissiveIntensity=i),Promise.resolve()}}class u{constructor(e){this.parser=e,this.name=a.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?i.EJi:null}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=[],r=n.extensions[this.name];if(void 0!==r.clearcoatFactor&&(t.clearcoat=r.clearcoatFactor),void 0!==r.clearcoatTexture&&o.push(s.assignTexture(t,"clearcoatMap",r.clearcoatTexture)),void 0!==r.clearcoatRoughnessFactor&&(t.clearcoatRoughness=r.clearcoatRoughnessFactor),void 0!==r.clearcoatRoughnessTexture&&o.push(s.assignTexture(t,"clearcoatRoughnessMap",r.clearcoatRoughnessTexture)),void 0!==r.clearcoatNormalTexture&&(o.push(s.assignTexture(t,"clearcoatNormalMap",r.clearcoatNormalTexture)),void 0!==r.clearcoatNormalTexture.scale)){const e=r.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new i.FM8(e,e)}return Promise.all(o)}}class d{constructor(e){this.parser=e,this.name=a.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?i.EJi:null}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const n=[],o=i.extensions[this.name];return void 0!==o.iridescenceFactor&&(t.iridescence=o.iridescenceFactor),void 0!==o.iridescenceTexture&&n.push(s.assignTexture(t,"iridescenceMap",o.iridescenceTexture)),void 0!==o.iridescenceIor&&(t.iridescenceIOR=o.iridescenceIor),void 0===t.iridescenceThicknessRange&&(t.iridescenceThicknessRange=[100,400]),void 0!==o.iridescenceThicknessMinimum&&(t.iridescenceThicknessRange[0]=o.iridescenceThicknessMinimum),void 0!==o.iridescenceThicknessMaximum&&(t.iridescenceThicknessRange[1]=o.iridescenceThicknessMaximum),void 0!==o.iridescenceThicknessTexture&&n.push(s.assignTexture(t,"iridescenceThicknessMap",o.iridescenceThicknessTexture)),Promise.all(n)}}class p{constructor(e){this.parser=e,this.name=a.KHR_MATERIALS_SHEEN}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?i.EJi:null}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=[];t.sheenColor=new i.Ilk(0,0,0),t.sheenRoughness=0,t.sheen=1;const r=n.extensions[this.name];if(void 0!==r.sheenColorFactor){const e=r.sheenColorFactor;t.sheenColor.setRGB(e[0],e[1],e[2],i.GUF)}return void 0!==r.sheenRoughnessFactor&&(t.sheenRoughness=r.sheenRoughnessFactor),void 0!==r.sheenColorTexture&&o.push(s.assignTexture(t,"sheenColorMap",r.sheenColorTexture,i.KI_)),void 0!==r.sheenRoughnessTexture&&o.push(s.assignTexture(t,"sheenRoughnessMap",r.sheenRoughnessTexture)),Promise.all(o)}}class m{constructor(e){this.parser=e,this.name=a.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?i.EJi:null}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const n=[],o=i.extensions[this.name];return void 0!==o.transmissionFactor&&(t.transmission=o.transmissionFactor),void 0!==o.transmissionTexture&&n.push(s.assignTexture(t,"transmissionMap",o.transmissionTexture)),Promise.all(n)}}class f{constructor(e){this.parser=e,this.name=a.KHR_MATERIALS_VOLUME}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?i.EJi:null}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=[],r=n.extensions[this.name];t.thickness=void 0!==r.thicknessFactor?r.thicknessFactor:0,void 0!==r.thicknessTexture&&o.push(s.assignTexture(t,"thicknessMap",r.thicknessTexture)),t.attenuationDistance=r.attenuationDistance||1/0;const a=r.attenuationColor||[1,1,1];return t.attenuationColor=(new i.Ilk).setRGB(a[0],a[1],a[2],i.GUF),Promise.all(o)}}class v{constructor(e){this.parser=e,this.name=a.KHR_MATERIALS_IOR}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?i.EJi:null}extendMaterialParams(e,t){const s=this.parser.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=s.extensions[this.name];return t.ior=void 0!==i.ior?i.ior:1.5,Promise.resolve()}}class y{constructor(e){this.parser=e,this.name=a.KHR_MATERIALS_SPECULAR}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?i.EJi:null}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=[],r=n.extensions[this.name];t.specularIntensity=void 0!==r.specularFactor?r.specularFactor:1,void 0!==r.specularTexture&&o.push(s.assignTexture(t,"specularIntensityMap",r.specularTexture));const a=r.specularColorFactor||[1,1,1];return t.specularColor=(new i.Ilk).setRGB(a[0],a[1],a[2],i.GUF),void 0!==r.specularColorTexture&&o.push(s.assignTexture(t,"specularColorMap",r.specularColorTexture,i.KI_)),Promise.all(o)}}class g{constructor(e){this.parser=e,this.name=a.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?i.EJi:null}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const n=[],o=i.extensions[this.name];return void 0!==o.anisotropyStrength&&(t.anisotropy=o.anisotropyStrength),void 0!==o.anisotropyRotation&&(t.anisotropyRotation=o.anisotropyRotation),void 0!==o.anisotropyTexture&&n.push(s.assignTexture(t,"anisotropyMap",o.anisotropyTexture)),Promise.all(n)}}class w{constructor(e){this.parser=e,this.name=a.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,s=t.json,i=s.textures[e];if(!i.extensions||!i.extensions[this.name])return null;const n=i.extensions[this.name],o=t.options.ktx2Loader;if(!o){if(s.extensionsRequired&&s.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,n.source,o)}}class x{constructor(e){this.parser=e,this.name=a.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,s=this.parser,i=s.json,n=i.textures[e];if(!n.extensions||!n.extensions[t])return null;const o=n.extensions[t],r=i.images[o.source];let a=s.textureLoader;if(r.uri){const e=s.options.manager.getHandler(r.uri);null!==e&&(a=e)}return this.detectSupport().then((function(n){if(n)return s.loadTextureImage(e,o.source,a);if(i.extensionsRequired&&i.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return s.loadTexture(e)}))}detectSupport(){return this.isSupported||(this.isSupported=new Promise((function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(1===t.height)}}))),this.isSupported}}class A{constructor(e){this.parser=e,this.name=a.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const t=this.name,s=this.parser,i=s.json,n=i.textures[e];if(!n.extensions||!n.extensions[t])return null;const o=n.extensions[t],r=i.images[o.source];let a=s.textureLoader;if(r.uri){const e=s.options.manager.getHandler(r.uri);null!==e&&(a=e)}return this.detectSupport().then((function(n){if(n)return s.loadTextureImage(e,o.source,a);if(i.extensionsRequired&&i.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return s.loadTexture(e)}))}detectSupport(){return this.isSupported||(this.isSupported=new Promise((function(e){const t=new Image;t.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",t.onload=t.onerror=function(){e(1===t.height)}}))),this.isSupported}}class b{constructor(e){this.name=a.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,s=t.bufferViews[e];if(s.extensions&&s.extensions[this.name]){const e=s.extensions[this.name],i=this.parser.getDependency("buffer",e.buffer),n=this.parser.options.meshoptDecoder;if(!n||!n.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return i.then((function(t){const s=e.byteOffset||0,i=e.byteLength||0,o=e.count,r=e.byteStride,a=new Uint8Array(t,s,i);return n.decodeGltfBufferAsync?n.decodeGltfBufferAsync(o,r,a,e.mode,e.filter).then((function(e){return e.buffer})):n.ready.then((function(){const t=new ArrayBuffer(o*r);return n.decodeGltfBuffer(new Uint8Array(t),o,r,a,e.mode,e.filter),t}))}))}return null}}class E{constructor(e){this.name=a.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,s=t.nodes[e];if(!s.extensions||!s.extensions[this.name]||void 0===s.mesh)return null;const n=t.meshes[s.mesh];for(const e of n.primitives)if(e.mode!==z.TRIANGLES&&e.mode!==z.TRIANGLE_STRIP&&e.mode!==z.TRIANGLE_FAN&&void 0!==e.mode)return null;const o=s.extensions[this.name].attributes,r=[],a={};for(const e in o)r.push(this.parser.getDependency("accessor",o[e]).then((t=>(a[e]=t,a[e]))));return r.length<1?null:(r.push(this.parser.createNodeMesh(e)),Promise.all(r).then((e=>{const t=e.pop(),s=t.isGroup?t.children:[t],n=e[0].count,o=[];for(const e of s){const t=new i.yGw,s=new i.Pa4,r=new i._fP,l=new i.Pa4(1,1,1),c=new i.SPe(e.geometry,e.material,n);for(let e=0;e<n;e++)a.TRANSLATION&&s.fromBufferAttribute(a.TRANSLATION,e),a.ROTATION&&r.fromBufferAttribute(a.ROTATION,e),a.SCALE&&l.fromBufferAttribute(a.SCALE,e),c.setMatrixAt(e,t.compose(s,r,l));for(const t in a)"TRANSLATION"!==t&&"ROTATION"!==t&&"SCALE"!==t&&e.geometry.setAttribute(t,a[t]);i.Tme.prototype.copy.call(c,e),this.parser.assignFinalMaterial(c),o.push(c)}return t.isGroup?(t.clear(),t.add(...o),t):o[0]})))}}const T="glTF",R=1313821514,S=5130562;class M{constructor(e){this.name=a.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,12),s=new TextDecoder;if(this.header={magic:s.decode(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==T)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const i=this.header.length-12,n=new DataView(e,12);let o=0;for(;o<i;){const t=n.getUint32(o,!0);o+=4;const i=n.getUint32(o,!0);if(o+=4,i===R){const i=new Uint8Array(e,12+o,t);this.content=s.decode(i)}else if(i===S){const s=12+o;this.body=e.slice(s,s+t)}o+=t}if(null===this.content)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class C{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=a.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const s=this.json,i=this.dracoLoader,n=e.extensions[this.name].bufferView,o=e.extensions[this.name].attributes,r={},a={},l={};for(const e in o){const t=j[e]||e.toLowerCase();r[t]=o[e]}for(const t in e.attributes){const i=j[t]||t.toLowerCase();if(void 0!==o[t]){const n=s.accessors[e.attributes[t]],o=B[n.componentType];l[i]=o.name,a[i]=!0===n.normalized}}return t.getDependency("bufferView",n).then((function(e){return new Promise((function(t){i.decodeDracoFile(e,(function(e){for(const t in e.attributes){const s=e.attributes[t],i=a[t];void 0!==i&&(s.normalized=i)}t(e)}),r,l)}))}))}}class I{constructor(){this.name=a.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return void 0!==t.texCoord&&t.texCoord!==e.channel||void 0!==t.offset||void 0!==t.rotation||void 0!==t.scale?(e=e.clone(),void 0!==t.texCoord&&(e.channel=t.texCoord),void 0!==t.offset&&e.offset.fromArray(t.offset),void 0!==t.rotation&&(e.rotation=t.rotation),void 0!==t.scale&&e.repeat.fromArray(t.scale),e.needsUpdate=!0,e):e}}class N{constructor(){this.name=a.KHR_MESH_QUANTIZATION}}class L extends i._C8{constructor(e,t,s,i){super(e,t,s,i)}copySampleValue_(e){const t=this.resultBuffer,s=this.sampleValues,i=this.valueSize,n=e*i*3+i;for(let e=0;e!==i;e++)t[e]=s[n+e];return t}interpolate_(e,t,s,i){const n=this.resultBuffer,o=this.sampleValues,r=this.valueSize,a=2*r,l=3*r,c=i-t,h=(s-t)/c,u=h*h,d=u*h,p=e*l,m=p-l,f=-2*d+3*u,v=d-u,y=1-f,g=v-u+h;for(let e=0;e!==r;e++){const t=o[m+e+r],s=o[m+e+a]*c,i=o[p+e+r],l=o[p+e]*c;n[e]=y*t+g*s+f*i+v*l}return n}}const F=new i._fP;class P extends L{interpolate_(e,t,s,i){const n=super.interpolate_(e,t,s,i);return F.fromArray(n).normalize().toArray(n),n}}const z={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},B={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},_={9728:i.TyD,9729:i.wem,9984:i.YLQ,9985:i.qyh,9986:i.aH4,9987:i.D1R},O={33071:i.uWy,33648:i.OoA,10497:i.rpg},k={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},j={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},q={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},H={CUBICSPLINE:void 0,LINEAR:i.NMF,STEP:i.Syv},D="OPAQUE",U="MASK",G="BLEND";function V(e,t,s){for(const i in s.extensions)void 0===e[i]&&(t.userData.gltfExtensions=t.userData.gltfExtensions||{},t.userData.gltfExtensions[i]=s.extensions[i])}function W(e,t){void 0!==t.extras&&"object"==typeof t.extras&&Object.assign(e.userData,t.extras)}function K(e,t){if(e.updateMorphTargets(),void 0!==t.weights)for(let s=0,i=t.weights.length;s<i;s++)e.morphTargetInfluences[s]=t.weights[s];if(t.extras&&Array.isArray(t.extras.targetNames)){const s=t.extras.targetNames;if(e.morphTargetInfluences.length===s.length){e.morphTargetDictionary={};for(let t=0,i=s.length;t<i;t++)e.morphTargetDictionary[s[t]]=t}}}function X(e){let t;const s=e.extensions&&e.extensions[a.KHR_DRACO_MESH_COMPRESSION];if(t=s?"draco:"+s.bufferView+":"+s.indices+":"+Y(s.attributes):e.indices+":"+Y(e.attributes)+":"+e.mode,void 0!==e.targets)for(let s=0,i=e.targets.length;s<i;s++)t+=":"+Y(e.targets[s]);return t}function Y(e){let t="";const s=Object.keys(e).sort();for(let i=0,n=s.length;i<n;i++)t+=s[i]+":"+e[s[i]]+";";return t}function Z(e){switch(e){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}const Q=new i.yGw;class J{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new r,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let s=!1,n=!1,o=-1;"undefined"!=typeof navigator&&(s=!0===/^((?!chrome|android).)*safari/i.test(navigator.userAgent),n=navigator.userAgent.indexOf("Firefox")>-1,o=n?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),"undefined"==typeof createImageBitmap||s||n&&o<98?this.textureLoader=new i.dpR(this.options.manager):this.textureLoader=new i.QRU(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new i.hH6(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),"use-credentials"===this.options.crossOrigin&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const s=this,i=this.json,n=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll((function(e){return e._markDefs&&e._markDefs()})),Promise.all(this._invokeAll((function(e){return e.beforeRoot&&e.beforeRoot()}))).then((function(){return Promise.all([s.getDependencies("scene"),s.getDependencies("animation"),s.getDependencies("camera")])})).then((function(t){const o={scene:t[0][i.scene||0],scenes:t[0],animations:t[1],cameras:t[2],asset:i.asset,parser:s,userData:{}};return V(n,o,i),W(o,i),Promise.all(s._invokeAll((function(e){return e.afterRoot&&e.afterRoot(o)}))).then((function(){e(o)}))})).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],s=this.json.meshes||[];for(let s=0,i=t.length;s<i;s++){const i=t[s].joints;for(let t=0,s=i.length;t<s;t++)e[i[t]].isBone=!0}for(let t=0,i=e.length;t<i;t++){const i=e[t];void 0!==i.mesh&&(this._addNodeRef(this.meshCache,i.mesh),void 0!==i.skin&&(s[i.mesh].isSkinnedMesh=!0)),void 0!==i.camera&&this._addNodeRef(this.cameraCache,i.camera)}}_addNodeRef(e,t){void 0!==t&&(void 0===e.refs[t]&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,s){if(e.refs[t]<=1)return s;const i=s.clone(),n=(e,t)=>{const s=this.associations.get(e);null!=s&&this.associations.set(t,s);for(const[s,i]of e.children.entries())n(i,t.children[s])};return n(s,i),i.name+="_instance_"+e.uses[t]++,i}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let s=0;s<t.length;s++){const i=e(t[s]);if(i)return i}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const s=[];for(let i=0;i<t.length;i++){const n=e(t[i]);n&&s.push(n)}return s}getDependency(e,t){const s=e+":"+t;let i=this.cache.get(s);if(!i){switch(e){case"scene":i=this.loadScene(t);break;case"node":i=this._invokeOne((function(e){return e.loadNode&&e.loadNode(t)}));break;case"mesh":i=this._invokeOne((function(e){return e.loadMesh&&e.loadMesh(t)}));break;case"accessor":i=this.loadAccessor(t);break;case"bufferView":i=this._invokeOne((function(e){return e.loadBufferView&&e.loadBufferView(t)}));break;case"buffer":i=this.loadBuffer(t);break;case"material":i=this._invokeOne((function(e){return e.loadMaterial&&e.loadMaterial(t)}));break;case"texture":i=this._invokeOne((function(e){return e.loadTexture&&e.loadTexture(t)}));break;case"skin":i=this.loadSkin(t);break;case"animation":i=this._invokeOne((function(e){return e.loadAnimation&&e.loadAnimation(t)}));break;case"camera":i=this.loadCamera(t);break;default:if(i=this._invokeOne((function(s){return s!=this&&s.getDependency&&s.getDependency(e,t)})),!i)throw new Error("Unknown type: "+e)}this.cache.add(s,i)}return i}getDependencies(e){let t=this.cache.get(e);if(!t){const s=this,i=this.json[e+("mesh"===e?"es":"s")]||[];t=Promise.all(i.map((function(t,i){return s.getDependency(e,i)}))),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],s=this.fileLoader;if(t.type&&"arraybuffer"!==t.type)throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(void 0===t.uri&&0===e)return Promise.resolve(this.extensions[a.KHR_BINARY_GLTF].body);const n=this.options;return new Promise((function(e,o){s.load(i.Zp0.resolveURL(t.uri,n.path),e,void 0,(function(){o(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))}))}))}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then((function(e){const s=t.byteLength||0,i=t.byteOffset||0;return e.slice(i,i+s)}))}loadAccessor(e){const t=this,s=this.json,n=this.json.accessors[e];if(void 0===n.bufferView&&void 0===n.sparse){const e=k[n.type],t=B[n.componentType],s=!0===n.normalized,o=new t(n.count*e);return Promise.resolve(new i.TlE(o,e,s))}const o=[];return void 0!==n.bufferView?o.push(this.getDependency("bufferView",n.bufferView)):o.push(null),void 0!==n.sparse&&(o.push(this.getDependency("bufferView",n.sparse.indices.bufferView)),o.push(this.getDependency("bufferView",n.sparse.values.bufferView))),Promise.all(o).then((function(e){const o=e[0],r=k[n.type],a=B[n.componentType],l=a.BYTES_PER_ELEMENT,c=l*r,h=n.byteOffset||0,u=void 0!==n.bufferView?s.bufferViews[n.bufferView].byteStride:void 0,d=!0===n.normalized;let p,m;if(u&&u!==c){const e=Math.floor(h/u),s="InterleavedBuffer:"+n.bufferView+":"+n.componentType+":"+e+":"+n.count;let c=t.cache.get(s);c||(p=new a(o,e*u,n.count*u/l),c=new i.vpT(p,u/l),t.cache.add(s,c)),m=new i.kB5(c,r,h%u/l,d)}else p=null===o?new a(n.count*r):new a(o,h,n.count*r),m=new i.TlE(p,r,d);if(void 0!==n.sparse){const t=k.SCALAR,s=B[n.sparse.indices.componentType],l=n.sparse.indices.byteOffset||0,c=n.sparse.values.byteOffset||0,h=new s(e[1],l,n.sparse.count*t),u=new a(e[2],c,n.sparse.count*r);null!==o&&(m=new i.TlE(m.array.slice(),m.itemSize,m.normalized));for(let e=0,t=h.length;e<t;e++){const t=h[e];if(m.setX(t,u[e*r]),r>=2&&m.setY(t,u[e*r+1]),r>=3&&m.setZ(t,u[e*r+2]),r>=4&&m.setW(t,u[e*r+3]),r>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return m}))}loadTexture(e){const t=this.json,s=this.options,i=t.textures[e].source,n=t.images[i];let o=this.textureLoader;if(n.uri){const e=s.manager.getHandler(n.uri);null!==e&&(o=e)}return this.loadTextureImage(e,i,o)}loadTextureImage(e,t,s){const n=this,o=this.json,r=o.textures[e],a=o.images[t],l=(a.uri||a.bufferView)+":"+r.sampler;if(this.textureCache[l])return this.textureCache[l];const c=this.loadImageSource(t,s).then((function(t){t.flipY=!1,t.name=r.name||a.name||"",""===t.name&&"string"==typeof a.uri&&!1===a.uri.startsWith("data:image/")&&(t.name=a.uri);const s=(o.samplers||{})[r.sampler]||{};return t.magFilter=_[s.magFilter]||i.wem,t.minFilter=_[s.minFilter]||i.D1R,t.wrapS=O[s.wrapS]||i.rpg,t.wrapT=O[s.wrapT]||i.rpg,n.associations.set(t,{textures:e}),t})).catch((function(){return null}));return this.textureCache[l]=c,c}loadImageSource(e,t){const s=this,n=this.json,o=this.options;if(void 0!==this.sourceCache[e])return this.sourceCache[e].then((e=>e.clone()));const r=n.images[e],a=self.URL||self.webkitURL;let l=r.uri||"",c=!1;if(void 0!==r.bufferView)l=s.getDependency("bufferView",r.bufferView).then((function(e){c=!0;const t=new Blob([e],{type:r.mimeType});return l=a.createObjectURL(t),l}));else if(void 0===r.uri)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const h=Promise.resolve(l).then((function(e){return new Promise((function(s,n){let r=s;!0===t.isImageBitmapLoader&&(r=function(e){const t=new i.xEZ(e);t.needsUpdate=!0,s(t)}),t.load(i.Zp0.resolveURL(e,o.path),r,void 0,n)}))})).then((function(e){var t;return!0===c&&a.revokeObjectURL(l),e.userData.mimeType=r.mimeType||((t=r.uri).search(/\.jpe?g($|\?)/i)>0||0===t.search(/^data\:image\/jpeg/)?"image/jpeg":t.search(/\.webp($|\?)/i)>0||0===t.search(/^data\:image\/webp/)?"image/webp":"image/png"),e})).catch((function(e){throw e}));return this.sourceCache[e]=h,h}assignTexture(e,t,s,i){const n=this;return this.getDependency("texture",s.index).then((function(o){if(!o)return null;if(void 0!==s.texCoord&&s.texCoord>0&&((o=o.clone()).channel=s.texCoord),n.extensions[a.KHR_TEXTURE_TRANSFORM]){const e=void 0!==s.extensions?s.extensions[a.KHR_TEXTURE_TRANSFORM]:void 0;if(e){const t=n.associations.get(o);o=n.extensions[a.KHR_TEXTURE_TRANSFORM].extendTexture(o,e),n.associations.set(o,t)}}return void 0!==i&&(o.colorSpace=i),e[t]=o,o}))}assignFinalMaterial(e){const t=e.geometry;let s=e.material;const n=void 0===t.attributes.tangent,o=void 0!==t.attributes.color,r=void 0===t.attributes.normal;if(e.isPoints){const e="PointsMaterial:"+s.uuid;let t=this.cache.get(e);t||(t=new i.UY4,i.F5T.prototype.copy.call(t,s),t.color.copy(s.color),t.map=s.map,t.sizeAttenuation=!1,this.cache.add(e,t)),s=t}else if(e.isLine){const e="LineBasicMaterial:"+s.uuid;let t=this.cache.get(e);t||(t=new i.nls,i.F5T.prototype.copy.call(t,s),t.color.copy(s.color),t.map=s.map,this.cache.add(e,t)),s=t}if(n||o||r){let e="ClonedMaterial:"+s.uuid+":";n&&(e+="derivative-tangents:"),o&&(e+="vertex-colors:"),r&&(e+="flat-shading:");let t=this.cache.get(e);t||(t=s.clone(),o&&(t.vertexColors=!0),r&&(t.flatShading=!0),n&&(t.normalScale&&(t.normalScale.y*=-1),t.clearcoatNormalScale&&(t.clearcoatNormalScale.y*=-1)),this.cache.add(e,t),this.associations.set(t,this.associations.get(s))),s=t}e.material=s}getMaterialType(){return i.Wid}loadMaterial(e){const t=this,s=this.json,n=this.extensions,o=s.materials[e];let r;const l={},c=[];if((o.extensions||{})[a.KHR_MATERIALS_UNLIT]){const e=n[a.KHR_MATERIALS_UNLIT];r=e.getMaterialType(),c.push(e.extendParams(l,o,t))}else{const s=o.pbrMetallicRoughness||{};if(l.color=new i.Ilk(1,1,1),l.opacity=1,Array.isArray(s.baseColorFactor)){const e=s.baseColorFactor;l.color.setRGB(e[0],e[1],e[2],i.GUF),l.opacity=e[3]}void 0!==s.baseColorTexture&&c.push(t.assignTexture(l,"map",s.baseColorTexture,i.KI_)),l.metalness=void 0!==s.metallicFactor?s.metallicFactor:1,l.roughness=void 0!==s.roughnessFactor?s.roughnessFactor:1,void 0!==s.metallicRoughnessTexture&&(c.push(t.assignTexture(l,"metalnessMap",s.metallicRoughnessTexture)),c.push(t.assignTexture(l,"roughnessMap",s.metallicRoughnessTexture))),r=this._invokeOne((function(t){return t.getMaterialType&&t.getMaterialType(e)})),c.push(Promise.all(this._invokeAll((function(t){return t.extendMaterialParams&&t.extendMaterialParams(e,l)}))))}!0===o.doubleSided&&(l.side=i.ehD);const h=o.alphaMode||D;if(h===G?(l.transparent=!0,l.depthWrite=!1):(l.transparent=!1,h===U&&(l.alphaTest=void 0!==o.alphaCutoff?o.alphaCutoff:.5)),void 0!==o.normalTexture&&r!==i.vBJ&&(c.push(t.assignTexture(l,"normalMap",o.normalTexture)),l.normalScale=new i.FM8(1,1),void 0!==o.normalTexture.scale)){const e=o.normalTexture.scale;l.normalScale.set(e,e)}if(void 0!==o.occlusionTexture&&r!==i.vBJ&&(c.push(t.assignTexture(l,"aoMap",o.occlusionTexture)),void 0!==o.occlusionTexture.strength&&(l.aoMapIntensity=o.occlusionTexture.strength)),void 0!==o.emissiveFactor&&r!==i.vBJ){const e=o.emissiveFactor;l.emissive=(new i.Ilk).setRGB(e[0],e[1],e[2],i.GUF)}return void 0!==o.emissiveTexture&&r!==i.vBJ&&c.push(t.assignTexture(l,"emissiveMap",o.emissiveTexture,i.KI_)),Promise.all(c).then((function(){const s=new r(l);return o.name&&(s.name=o.name),W(s,o),t.associations.set(s,{materials:e}),o.extensions&&V(n,s,o),s}))}createUniqueName(e){const t=i.iUV.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,s=this.extensions,n=this.primitiveCache;function o(e){return s[a.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e,t).then((function(s){return $(s,e,t)}))}const r=[];for(let s=0,l=e.length;s<l;s++){const l=e[s],c=X(l),h=n[c];if(h)r.push(h.promise);else{let e;e=l.extensions&&l.extensions[a.KHR_DRACO_MESH_COMPRESSION]?o(l):$(new i.u9r,l,t),n[c]={primitive:l,promise:e},r.push(e)}}return Promise.all(r)}loadMesh(e){const t=this,s=this.json,o=this.extensions,r=s.meshes[e],a=r.primitives,l=[];for(let e=0,t=a.length;e<t;e++){const t=void 0===a[e].material?(void 0===(c=this.cache).DefaultMaterial&&(c.DefaultMaterial=new i.Wid({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:i.Wl3})),c.DefaultMaterial):this.getDependency("material",a[e].material);l.push(t)}var c;return l.push(t.loadGeometries(a)),Promise.all(l).then((function(s){const l=s.slice(0,s.length-1),c=s[s.length-1],h=[];for(let s=0,u=c.length;s<u;s++){const u=c[s],d=a[s];let p;const m=l[s];if(d.mode===z.TRIANGLES||d.mode===z.TRIANGLE_STRIP||d.mode===z.TRIANGLE_FAN||void 0===d.mode)p=!0===r.isSkinnedMesh?new i.TUv(u,m):new i.Kj0(u,m),!0===p.isSkinnedMesh&&p.normalizeSkinWeights(),d.mode===z.TRIANGLE_STRIP?p.geometry=n(p.geometry,i.UlW):d.mode===z.TRIANGLE_FAN&&(p.geometry=n(p.geometry,i.z$h));else if(d.mode===z.LINES)p=new i.ejS(u,m);else if(d.mode===z.LINE_STRIP)p=new i.x12(u,m);else if(d.mode===z.LINE_LOOP)p=new i.blk(u,m);else{if(d.mode!==z.POINTS)throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+d.mode);p=new i.woe(u,m)}Object.keys(p.geometry.morphAttributes).length>0&&K(p,r),p.name=t.createUniqueName(r.name||"mesh_"+e),W(p,r),d.extensions&&V(o,p,d),t.assignFinalMaterial(p),h.push(p)}for(let s=0,i=h.length;s<i;s++)t.associations.set(h[s],{meshes:e,primitives:s});if(1===h.length)return r.extensions&&V(o,h[0],r),h[0];const u=new i.ZAu;r.extensions&&V(o,u,r),t.associations.set(u,{meshes:e});for(let e=0,t=h.length;e<t;e++)u.add(h[e]);return u}))}loadCamera(e){let t;const s=this.json.cameras[e],n=s[s.type];if(n)return"perspective"===s.type?t=new i.cPb(i.M8C.radToDeg(n.yfov),n.aspectRatio||1,n.znear||1,n.zfar||2e6):"orthographic"===s.type&&(t=new i.iKG(-n.xmag,n.xmag,n.ymag,-n.ymag,n.znear,n.zfar)),s.name&&(t.name=this.createUniqueName(s.name)),W(t,s),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],s=[];for(let e=0,i=t.joints.length;e<i;e++)s.push(this._loadNodeShallow(t.joints[e]));return void 0!==t.inverseBindMatrices?s.push(this.getDependency("accessor",t.inverseBindMatrices)):s.push(null),Promise.all(s).then((function(e){const t=e.pop(),s=e,n=[],o=[];for(let e=0,r=s.length;e<r;e++){const r=s[e];if(r){n.push(r);const s=new i.yGw;null!==t&&s.fromArray(t.array,16*e),o.push(s)}}return new i.OdW(n,o)}))}loadAnimation(e){const t=this.json,s=this,n=t.animations[e],o=n.name?n.name:"animation_"+e,r=[],a=[],l=[],c=[],h=[];for(let e=0,t=n.channels.length;e<t;e++){const t=n.channels[e],s=n.samplers[t.sampler],i=t.target,o=i.node,u=void 0!==n.parameters?n.parameters[s.input]:s.input,d=void 0!==n.parameters?n.parameters[s.output]:s.output;void 0!==i.node&&(r.push(this.getDependency("node",o)),a.push(this.getDependency("accessor",u)),l.push(this.getDependency("accessor",d)),c.push(s),h.push(i))}return Promise.all([Promise.all(r),Promise.all(a),Promise.all(l),Promise.all(c),Promise.all(h)]).then((function(e){const t=e[0],n=e[1],r=e[2],a=e[3],l=e[4],c=[];for(let e=0,i=t.length;e<i;e++){const i=t[e],o=n[e],h=r[e],u=a[e],d=l[e];if(void 0===i)continue;i.updateMatrix&&i.updateMatrix();const p=s._createAnimationTracks(i,o,h,u,d);if(p)for(let e=0;e<p.length;e++)c.push(p[e])}return new i.m7l(o,void 0,c)}))}createNodeMesh(e){const t=this.json,s=this,i=t.nodes[e];return void 0===i.mesh?null:s.getDependency("mesh",i.mesh).then((function(e){const t=s._getNodeRef(s.meshCache,i.mesh,e);return void 0!==i.weights&&t.traverse((function(e){if(e.isMesh)for(let t=0,s=i.weights.length;t<s;t++)e.morphTargetInfluences[t]=i.weights[t]})),t}))}loadNode(e){const t=this,s=this.json.nodes[e],i=t._loadNodeShallow(e),n=[],o=s.children||[];for(let e=0,s=o.length;e<s;e++)n.push(t.getDependency("node",o[e]));const r=void 0===s.skin?Promise.resolve(null):t.getDependency("skin",s.skin);return Promise.all([i,Promise.all(n),r]).then((function(e){const t=e[0],s=e[1],i=e[2];null!==i&&t.traverse((function(e){e.isSkinnedMesh&&e.bind(i,Q)}));for(let e=0,i=s.length;e<i;e++)t.add(s[e]);return t}))}_loadNodeShallow(e){const t=this.json,s=this.extensions,n=this;if(void 0!==this.nodeCache[e])return this.nodeCache[e];const o=t.nodes[e],r=o.name?n.createUniqueName(o.name):"",a=[],l=n._invokeOne((function(t){return t.createNodeMesh&&t.createNodeMesh(e)}));return l&&a.push(l),void 0!==o.camera&&a.push(n.getDependency("camera",o.camera).then((function(e){return n._getNodeRef(n.cameraCache,o.camera,e)}))),n._invokeAll((function(t){return t.createNodeAttachment&&t.createNodeAttachment(e)})).forEach((function(e){a.push(e)})),this.nodeCache[e]=Promise.all(a).then((function(t){let a;if(a=!0===o.isBone?new i.N$j:t.length>1?new i.ZAu:1===t.length?t[0]:new i.Tme,a!==t[0])for(let e=0,s=t.length;e<s;e++)a.add(t[e]);if(o.name&&(a.userData.name=o.name,a.name=r),W(a,o),o.extensions&&V(s,a,o),void 0!==o.matrix){const e=new i.yGw;e.fromArray(o.matrix),a.applyMatrix4(e)}else void 0!==o.translation&&a.position.fromArray(o.translation),void 0!==o.rotation&&a.quaternion.fromArray(o.rotation),void 0!==o.scale&&a.scale.fromArray(o.scale);return n.associations.has(a)||n.associations.set(a,{}),n.associations.get(a).nodes=e,a})),this.nodeCache[e]}loadScene(e){const t=this.extensions,s=this.json.scenes[e],n=this,o=new i.ZAu;s.name&&(o.name=n.createUniqueName(s.name)),W(o,s),s.extensions&&V(t,o,s);const r=s.nodes||[],a=[];for(let e=0,t=r.length;e<t;e++)a.push(n.getDependency("node",r[e]));return Promise.all(a).then((function(e){for(let t=0,s=e.length;t<s;t++)o.add(e[t]);return n.associations=(e=>{const t=new Map;for(const[e,s]of n.associations)(e instanceof i.F5T||e instanceof i.xEZ)&&t.set(e,s);return e.traverse((e=>{const s=n.associations.get(e);null!=s&&t.set(e,s)})),t})(o),o}))}_createAnimationTracks(e,t,s,n,o){const r=[],a=e.name?e.name:e.uuid,l=[];let c;switch(q[o.path]===q.weights?e.traverse((function(e){e.morphTargetInfluences&&l.push(e.name?e.name:e.uuid)})):l.push(a),q[o.path]){case q.weights:c=i.dUE;break;case q.rotation:c=i.iLg;break;case q.position:case q.scale:c=i.yC1;break;default:if(1===s.itemSize)c=i.dUE;else c=i.yC1}const h=void 0!==n.interpolation?H[n.interpolation]:i.NMF,u=this._getArrayFromAccessor(s);for(let e=0,s=l.length;e<s;e++){const s=new c(l[e]+"."+q[o.path],t.array,u,h);"CUBICSPLINE"===n.interpolation&&this._createCubicSplineTrackInterpolant(s),r.push(s)}return r}_getArrayFromAccessor(e){let t=e.array;if(e.normalized){const e=Z(t.constructor),s=new Float32Array(t.length);for(let i=0,n=t.length;i<n;i++)s[i]=t[i]*e;t=s}return t}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(e){return new(this instanceof i.iLg?P:L)(this.times,this.values,this.getValueSize()/3,e)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function $(e,t,s){const n=t.attributes,o=[];function r(t,i){return s.getDependency("accessor",t).then((function(t){e.setAttribute(i,t)}))}for(const t in n){const s=j[t]||t.toLowerCase();s in e.attributes||o.push(r(n[t],s))}if(void 0!==t.indices&&!e.index){const i=s.getDependency("accessor",t.indices).then((function(t){e.setIndex(t)}));o.push(i)}return i.epp.workingColorSpace,i.GUF,W(e,t),function(e,t,s){const n=t.attributes,o=new i.ZzF;if(void 0===n.POSITION)return;{const e=s.json.accessors[n.POSITION],t=e.min,r=e.max;if(void 0===t||void 0===r)return;if(o.set(new i.Pa4(t[0],t[1],t[2]),new i.Pa4(r[0],r[1],r[2])),e.normalized){const t=Z(B[e.componentType]);o.min.multiplyScalar(t),o.max.multiplyScalar(t)}}const r=t.targets;if(void 0!==r){const e=new i.Pa4,t=new i.Pa4;for(let i=0,n=r.length;i<n;i++){const n=r[i];if(void 0!==n.POSITION){const i=s.json.accessors[n.POSITION],o=i.min,r=i.max;if(void 0!==o&&void 0!==r){if(t.setX(Math.max(Math.abs(o[0]),Math.abs(r[0]))),t.setY(Math.max(Math.abs(o[1]),Math.abs(r[1]))),t.setZ(Math.max(Math.abs(o[2]),Math.abs(r[2]))),i.normalized){const e=Z(B[i.componentType]);t.multiplyScalar(e)}e.max(t)}}}o.expandByVector(e)}e.boundingBox=o;const a=new i.aLr;o.getCenter(a.center),a.radius=o.min.distanceTo(o.max)/2,e.boundingSphere=a}(e,t,s),Promise.all(o).then((function(){return void 0!==t.targets?function(e,t,s){let i=!1,n=!1,o=!1;for(let e=0,s=t.length;e<s;e++){const s=t[e];if(void 0!==s.POSITION&&(i=!0),void 0!==s.NORMAL&&(n=!0),void 0!==s.COLOR_0&&(o=!0),i&&n&&o)break}if(!i&&!n&&!o)return Promise.resolve(e);const r=[],a=[],l=[];for(let c=0,h=t.length;c<h;c++){const h=t[c];if(i){const t=void 0!==h.POSITION?s.getDependency("accessor",h.POSITION):e.attributes.position;r.push(t)}if(n){const t=void 0!==h.NORMAL?s.getDependency("accessor",h.NORMAL):e.attributes.normal;a.push(t)}if(o){const t=void 0!==h.COLOR_0?s.getDependency("accessor",h.COLOR_0):e.attributes.color;l.push(t)}}return Promise.all([Promise.all(r),Promise.all(a),Promise.all(l)]).then((function(t){const s=t[0],r=t[1],a=t[2];return i&&(e.morphAttributes.position=s),n&&(e.morphAttributes.normal=r),o&&(e.morphAttributes.color=a),e.morphTargetsRelative=!0,e}))}(e,t.targets,s):e}))}}}]);